{% extends "base.html" %}

{% block title %}NegMAS App - Negotiations{% endblock %}

{% block content %}
<!-- Negotiations Table View when no negotiation selected -->
<div x-show="!currentNegotiation" class="negotiations-table-view" x-init="initNegotiationsTables()">
    <!-- Header with actions -->
    <div class="table-header">
        <h2>Negotiations</h2>
        <div style="display: flex; gap: 8px; align-items: center;">
            <button class="btn btn-secondary btn-sm" @click="loadSavedNegotiations()" :disabled="savedNegotiationsLoading">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                    <polyline points="17 8 12 3 7 8"/>
                    <line x1="12" y1="3" x2="12" y2="15"/>
                </svg>
                <span x-text="savedNegotiationsLoading ? 'Loading...' : 'Load Saved'"></span>
            </button>
            <button class="btn btn-primary" @click="openNewNegotiation()">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                    <line x1="12" y1="5" x2="12" y2="19"></line>
                    <line x1="5" y1="12" x2="19" y2="12"></line>
                </svg>
                Start Negotiation
            </button>
        </div>
    </div>
    
    <!-- Running Negotiations Section -->
    <div class="table-section" x-show="runningNegotiations.length > 0" style="margin-bottom: 24px;">
        <h3>
            <span class="status-dot running"></span>
            Running (<span x-text="runningNegotiations.length"></span>)
        </h3>
        <div id="running-negotiations-table"></div>
    </div>
    
    <!-- Completed Negotiations Section (current session) -->
    <div class="table-section" style="flex: 1; display: flex; flex-direction: column; min-height: 0;">
        <h3>
            <span class="status-dot" style="background: var(--success);"></span>
            Completed This Session (<span x-text="completedNegotiations.length"></span>)
        </h3>
        
        <template x-if="completedNegotiations.length === 0 && runningNegotiations.length === 0 && savedNegotiations.length === 0">
            <div class="empty-state" style="flex: 1;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                    <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
                </svg>
                <div class="empty-state-title">No Negotiations Yet</div>
                <div class="empty-state-text">
                    Start a new negotiation or load saved ones.
                </div>
            </div>
        </template>
        
        <div id="completed-negotiations-table" x-show="completedNegotiations.length > 0"></div>
    </div>
    
    <!-- Saved Negotiations Section -->
    <div class="table-section saved-negotiations-section" x-show="savedNegotiations.length > 0" style="flex: 1; display: flex; flex-direction: column; min-height: 0;">
        <h3>
            <span style="display: flex; align-items: center; gap: 8px;">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="16" height="16">
                    <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"/>
                </svg>
                Saved (<span x-text="savedNegotiations.length"></span>)
            </span>
            <button class="btn btn-ghost btn-xs" @click="clearSavedNegotiations()" title="Clear all saved">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14">
                    <polyline points="3 6 5 6 21 6"></polyline>
                    <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                </svg>
            </button>
        </h3>
        <div id="saved-negotiations-table"></div>
    </div>
</div>

<!-- Zoomed panel overlay -->
<div class="panel-zoom-overlay" x-show="zoomedPanel" @click.self="zoomedPanel = null" 
     style="position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 1000; display: flex; align-items: center; justify-content: center; padding: 20px;">
    <div class="panel" style="width: 90vw; height: 90vh; max-width: none;" x-show="zoomedPanel">
        <div class="panel-header">
            <span class="panel-title" x-text="zoomedPanel"></span>
            <div class="panel-actions">
                <button class="panel-btn" title="Close" @click="zoomedPanel = null">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>
        </div>
        <div class="panel-content" style="padding: 0; position: relative; height: calc(100% - 48px);">
            <div :id="'zoomed-' + zoomedPanel?.replace(/\s+/g, '-').toLowerCase()" style="width: 100%; height: 100%;"></div>
        </div>
    </div>
</div>

<!-- Scenario Stats Modal -->
<div class="panel-zoom-overlay" x-show="showScenarioStatsModal" @click.self="showScenarioStatsModal = false" 
     style="position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 1000; display: flex; align-items: center; justify-content: center; padding: 20px;">
    <div class="panel" style="width: 600px; max-width: 90vw; max-height: 90vh; overflow: auto;" x-show="showScenarioStatsModal">
        <div class="panel-header">
            <span class="panel-title">Scenario Statistics</span>
            <div class="panel-actions">
                <button class="panel-btn" title="Close" @click="showScenarioStatsModal = false">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <line x1="18" y1="6" x2="6" y2="18"></line>
                        <line x1="6" y1="6" x2="18" y2="18"></line>
                    </svg>
                </button>
            </div>
        </div>
        <div class="panel-content" style="padding: 16px;">
            <!-- Loading state -->
            <div x-show="currentNegotiationStatsLoading" class="text-muted" style="padding: 20px; text-align: center;">
                Loading statistics...
            </div>
            
            <!-- Error state -->
            <div x-show="currentNegotiationStatsError" class="text-muted" style="padding: 20px; text-align: center; color: var(--danger);">
                <span x-text="currentNegotiationStatsError"></span>
            </div>
            
            <!-- Stats content -->
            <div x-show="currentNegotiationStats && currentNegotiationStats.has_stats && !currentNegotiationStatsLoading">
                <!-- Scenario name -->
                <div style="margin-bottom: 16px;">
                    <span class="text-muted" style="font-size: 12px;">Scenario:</span>
                    <span style="font-weight: 500;" x-text="currentNegotiation?.scenario || 'Unknown'"></span>
                </div>
                
                <!-- Opposition & Pareto count -->
                <div class="scenario-detail-grid" style="margin-bottom: 16px;">
                    <div class="scenario-detail-stat">
                        <span class="stat-label">Opposition</span>
                        <span class="stat-value" x-text="currentNegotiationStats?.opposition?.toFixed(3) ?? 'N/A'"></span>
                    </div>
                    <div class="scenario-detail-stat">
                        <span class="stat-label">Pareto Outcomes</span>
                        <span class="stat-value" x-text="currentNegotiationStats?.n_pareto_outcomes ?? 'N/A'"></span>
                    </div>
                </div>
                
                <!-- Utility Ranges -->
                <template x-if="currentNegotiationStats?.utility_ranges && currentNegotiationStats.utility_ranges.length > 0">
                    <div style="margin-bottom: 16px;">
                        <div class="text-muted" style="font-size: 12px; margin-bottom: 8px;">Utility Ranges</div>
                        <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                            <template x-for="(range, idx) in currentNegotiationStats.utility_ranges" :key="idx">
                                <span class="badge badge-neutral" 
                                      x-text="(currentNegotiationStats.negotiator_names?.[idx] || ('Party ' + (idx+1))) + ': [' + range[0].toFixed(3) + ', ' + range[1].toFixed(3) + ']'">
                                </span>
                            </template>
                        </div>
                    </div>
                </template>
                
                <!-- Special Points Table -->
                <div style="margin-bottom: 16px;">
                    <div class="text-muted" style="font-size: 12px; margin-bottom: 8px;">Special Points</div>
                    <table style="width: 100%; border-collapse: collapse; font-size: 13px;">
                        <thead>
                            <tr style="border-bottom: 1px solid var(--border-color);">
                                <th style="text-align: left; padding: 8px 12px; font-weight: 500;">Point</th>
                                <template x-for="(name, idx) in (currentNegotiationStats?.negotiator_names || [])" :key="idx">
                                    <th style="text-align: right; padding: 8px 12px; font-weight: 500;" x-text="name"></th>
                                </template>
                            </tr>
                        </thead>
                        <tbody>
                            <tr x-show="currentNegotiationStats?.nash_utils?.length > 0" style="border-bottom: 1px solid var(--border-color);">
                                <td style="padding: 8px 12px;">Nash</td>
                                <template x-for="(u, idx) in (currentNegotiationStats?.nash_utils?.[0] || [])" :key="idx">
                                    <td style="text-align: right; padding: 8px 12px; font-family: var(--font-mono);" x-text="u.toFixed(4)"></td>
                                </template>
                            </tr>
                            <tr x-show="currentNegotiationStats?.kalai_utils?.length > 0" style="border-bottom: 1px solid var(--border-color);">
                                <td style="padding: 8px 12px;">Kalai</td>
                                <template x-for="(u, idx) in (currentNegotiationStats?.kalai_utils?.[0] || [])" :key="idx">
                                    <td style="text-align: right; padding: 8px 12px; font-family: var(--font-mono);" x-text="u.toFixed(4)"></td>
                                </template>
                            </tr>
                            <tr x-show="currentNegotiationStats?.ks_utils?.length > 0" style="border-bottom: 1px solid var(--border-color);">
                                <td style="padding: 8px 12px;">Kalai-Smorodinsky</td>
                                <template x-for="(u, idx) in (currentNegotiationStats?.ks_utils?.[0] || [])" :key="idx">
                                    <td style="text-align: right; padding: 8px 12px; font-family: var(--font-mono);" x-text="u.toFixed(4)"></td>
                                </template>
                            </tr>
                            <tr x-show="currentNegotiationStats?.max_welfare_utils?.length > 0">
                                <td style="padding: 8px 12px;">Max Welfare</td>
                                <template x-for="(u, idx) in (currentNegotiationStats?.max_welfare_utils?.[0] || [])" :key="idx">
                                    <td style="text-align: right; padding: 8px 12px; font-family: var(--font-mono);" x-text="u.toFixed(4)"></td>
                                </template>
                            </tr>
                        </tbody>
                    </table>
                </div>
                
                <!-- Actions -->
                <div style="display: flex; gap: 8px; justify-content: flex-end;">
                    <button class="btn btn-secondary btn-sm" @click="calculateCurrentNegotiationStats(true)" :disabled="currentNegotiationStatsLoading">
                        Recalculate
                    </button>
                </div>
            </div>
            
            <!-- No stats state -->
            <div x-show="!currentNegotiationStatsLoading && !currentNegotiationStatsError && (!currentNegotiationStats || !currentNegotiationStats.has_stats)" 
                 style="padding: 20px; text-align: center;">
                <p class="text-muted" style="margin-bottom: 16px;">No statistics available for this scenario.</p>
                <button class="btn btn-primary btn-sm" @click="calculateCurrentNegotiationStats(false)" :disabled="currentNegotiationStatsLoading">
                    Calculate Stats
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Negotiation view when one is selected -->
<div x-show="currentNegotiation" class="panels-container panels-layout-compact">
    <!-- LEFT COLUMN: Info, Offer History, Result -->
    <div class="panels-column panels-column-left" x-ref="leftColumn">
        <!-- Negotiation Info Panel - Ultra Compact -->
        <div class="panel panel-compact panel-info" x-ref="panelInfo" :class="{'collapsed': panelCollapsed.info}">
            <span class="panel-collapsed-label" x-show="panelCollapsed.info">INFO</span>
            <div class="panel-floating-actions">
                <template x-if="currentNegotiation?.pendingStart">
                    <button class="panel-btn panel-btn-primary" title="Start" @click="actuallyStartNegotiation()">
                        <svg viewBox="0 0 24 24" fill="currentColor" width="12" height="12"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                    </button>
                </template>
                <template x-if="currentNegotiation && !currentNegotiation?.pendingStart && !currentNegotiation?.agreement && !currentNegotiation?.end_reason">
                    <div style="display: flex; gap: 2px;">
                        <button class="panel-btn" :title="currentNegotiation?.paused ? 'Resume' : 'Pause'" @click="togglePause()">
                            <svg x-show="!currentNegotiation?.paused" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>
                            <svg x-show="currentNegotiation?.paused" viewBox="0 0 24 24" fill="currentColor"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                        </button>
                        <button class="panel-btn" title="Cancel" @click="stopNegotiation()">
                            <svg viewBox="0 0 24 24" fill="currentColor"><rect x="4" y="4" width="16" height="16" rx="2"></rect></svg>
                        </button>
                    </div>
                </template>
                <button class="panel-btn panel-collapse-btn" title="Toggle panel" @click="panelCollapsed.info = !panelCollapsed.info">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </button>
                <button class="panel-btn" title="Scenario Stats" @click="showScenarioStatsModal = true; loadCurrentNegotiationStats()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18 20V10"/><path d="M12 20V4"/><path d="M6 20v-6"/></svg>
                </button>
            </div>
            <div class="panel-content-ultra-compact" x-show="!panelCollapsed.info">
                <!-- Row 1: Scenario + Status + Progress -->
                <div class="info-row">
                    <span class="info-scenario" x-text="currentNegotiation?.scenario"></span>
                    <span class="badge badge-xs" 
                          :class="{'badge-warning': currentNegotiation?.pendingStart, 'badge-primary': !currentNegotiation?.pendingStart && !currentNegotiation?.agreement && !currentNegotiation?.end_reason && !currentNegotiation?.paused, 'badge-info': currentNegotiation?.paused, 'badge-success': currentNegotiation?.agreement, 'badge-neutral': currentNegotiation?.end_reason && !currentNegotiation?.agreement}"
                          x-text="currentNegotiation?.pendingStart ? 'Pending' : (currentNegotiation?.agreement ? 'Done' : (currentNegotiation?.end_reason ? 'End' : (currentNegotiation?.paused ? 'Paused' : 'Running')))"></span>
                    <span class="info-stats" x-text="(currentNegotiation?.step || 0) + '/' + (currentNegotiation?.n_steps || '∞') + ' steps'"></span>
                    <span class="info-stats" x-text="(currentNegotiation?.offers?.length || 0) + ' offers'"></span>
                    <div class="info-progress" x-show="!currentNegotiation?.pendingStart && !currentNegotiation?.agreement && !currentNegotiation?.end_reason">
                        <div class="progress-mini"><div class="progress-bar" :style="'width: ' + Math.min(100, (currentNegotiation?.relative_time || 0) * 100) + '%'"></div></div>
                    </div>
                </div>
                <!-- Row 2: Negotiators (only if needed) -->
                <div class="info-row info-row-negotiators">
                    <template x-for="(name, idx) in (currentNegotiation?.negotiator_names || [])" :key="idx">
                        <span class="badge badge-xs" :style="'background: ' + (currentNegotiation?.negotiator_colors?.[idx] || 'var(--primary)') + '; color: white;'" x-text="name"></span>
                    </template>
                </div>
            </div>
        </div>
        
        <!-- Resize handle between Info and History -->
        <div class="resize-handle-horizontal" @mousedown="startPanelResize($event, 'info-history')"></div>
        
        <!-- Offer History Panel - Takes most space -->
        <div class="panel panel-compact panel-history" x-ref="panelHistory" :class="{'collapsed': panelCollapsed.history}">
            <span class="panel-collapsed-label" x-show="panelCollapsed.history">OFFERS</span>
            <div class="panel-floating-actions">
                <span class="text-muted" style="font-size: 9px;" x-text="(currentNegotiation?.offers?.length || 0)"></span>
                <button class="panel-btn" title="Save as JSON" @click="saveOffersAsJson()">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                </button>
                <button class="panel-btn" title="Zoom" @click="zoomPanel('Offer History', null)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" y1="3" x2="14" y2="10"/><line x1="3" y1="21" x2="10" y2="14"/></svg>
                </button>
                <button class="panel-btn panel-collapse-btn" title="Toggle panel" @click="panelCollapsed.history = !panelCollapsed.history">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </button>
            </div>
            <div class="panel-content panel-content-compact" style="padding: 4px;" x-show="!panelCollapsed.history">
                <div class="offer-log" x-ref="offerLog">
                    <template x-if="!currentNegotiation?.offers || currentNegotiation.offers.length === 0">
                        <div class="empty-state-mini"><span class="text-muted">Waiting for offers...</span></div>
                    </template>
                    <template x-for="(offer, idx) in (currentNegotiation?.offers || []).slice(-50)" :key="idx">
                        <div class="offer-item-compact animate-slide-up" :style="'border-left: 2px solid ' + (currentNegotiation?.negotiator_colors?.[offer.proposer_index] || 'var(--border-color)')">
                            <div class="offer-header-compact">
                                <span class="offer-agent" :style="'color: ' + (currentNegotiation?.negotiator_colors?.[offer.proposer_index] || 'inherit')" x-text="offer.proposer"></span>
                                <span class="offer-step" x-text="'#' + offer.step"></span>
                            </div>
                            <div class="offer-values-compact">
                                <template x-for="(value, key) in offer.offer" :key="key">
                                    <span><span class="text-muted" x-text="key + ':'"></span> <span x-text="value"></span></span>
                                </template>
                            </div>
                            <div class="offer-utilities-compact">
                                <template x-for="(util, uidx) in offer.utilities" :key="uidx">
                                    <span :style="'color: ' + (currentNegotiation?.negotiator_colors?.[uidx] || 'inherit')" x-text="util.toFixed(2)"></span>
                                </template>
                            </div>
                        </div>
                    </template>
                </div>
            </div>
        </div>
        
        <!-- Resize handle between History and Result -->
        <div class="resize-handle-horizontal" @mousedown="startPanelResize($event, 'history-result')"></div>
        
        <!-- Result Panel - Ultra Compact -->
        <div class="panel panel-compact panel-result" x-ref="panelResult" :class="{'collapsed': panelCollapsed.result}">
            <span class="panel-collapsed-label" x-show="panelCollapsed.result">RESULT</span>
            <div class="panel-floating-actions">
                <button class="panel-btn" title="Save Results" @click="saveResults()" x-show="currentNegotiation?.agreement || currentNegotiation?.end_reason">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                </button>
                <button class="panel-btn panel-collapse-btn" title="Toggle panel" @click="panelCollapsed.result = !panelCollapsed.result">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </button>
            </div>
            <div class="panel-content-ultra-compact" x-show="!panelCollapsed.result">
                <template x-if="currentNegotiation?.agreement">
                    <div class="result-row">
                        <template x-for="(value, key) in currentNegotiation.agreement" :key="key">
                            <span class="result-item"><span class="text-muted" x-text="key"></span>=<strong x-text="value"></strong></span>
                        </template>
                        <span class="result-separator">→</span>
                        <template x-for="(util, idx) in (currentNegotiation.final_utilities || [])" :key="idx">
                            <span class="result-utility" :style="'color: ' + (currentNegotiation?.negotiator_colors?.[idx] || 'var(--primary)')" x-text="util.toFixed(3)"></span>
                        </template>
                    </div>
                </template>
                <template x-if="currentNegotiation?.end_reason && !currentNegotiation?.agreement">
                    <div class="result-row">
                        <span class="badge badge-xs" :class="currentNegotiation.error ? 'badge-danger' : 'badge-warning'" x-text="currentNegotiation.error ? 'Error' : 'No Agreement'"></span>
                        <span class="text-muted result-reason" x-text="currentNegotiation.error || currentNegotiation.end_reason"></span>
                    </div>
                </template>
                <template x-if="!currentNegotiation?.end_reason && !currentNegotiation?.agreement && !currentNegotiation?.pendingStart">
                    <div class="result-row result-row-progress">
                        <div class="progress-container" style="flex: 1; display: flex; align-items: center; gap: 8px;">
                            <div class="progress-bar-container" style="flex: 1; height: 6px; background: var(--bg-tertiary); border-radius: 3px; overflow: hidden;">
                                <div class="progress-bar" 
                                     :style="'width: ' + Math.min(100, getNegotiationProgress(currentNegotiation) * 100) + '%'">
                                </div>
                            </div>
                            <span class="text-muted" style="font-size: 11px; min-width: 40px;" 
                                  x-text="Math.round(getNegotiationProgress(currentNegotiation) * 100) + '%'"></span>
                        </div>
                        <span class="text-muted" style="font-size: 10px; margin-left: 8px;" 
                              x-text="'Step ' + (currentNegotiation?.step || 0) + (currentNegotiation?.n_steps ? '/' + currentNegotiation.n_steps : '')"></span>
                    </div>
                </template>
                <template x-if="currentNegotiation?.pendingStart">
                    <div class="result-row result-row-center"><span class="text-muted">Ready</span></div>
                </template>
            </div>
        </div>
    </div>
    
    <!-- Resize handle between columns -->
    <div class="resize-handle-vertical" @mousedown="startColumnResize($event)" x-ref="columnResizer"></div>
    
    <!-- RIGHT COLUMN: 2D Utility View, Utility Timeline -->
    <div class="panels-column panels-column-right" x-ref="rightColumn">
        <!-- 2D Utility View Panel -->
        <div class="panel panel-compact panel-2d-utility" x-ref="panel2dUtility" :class="{'collapsed': panelCollapsed.utility2d}">
            <span class="panel-collapsed-label" x-show="panelCollapsed.utility2d">2D VIEW</span>
            <div class="panel-floating-actions">
                <div class="panel-inline-controls" x-show="currentNegotiation?.panelSettings?.adjustable && !panelCollapsed.utility2d">
                    <select class="form-select form-select-xs" x-model.number="panelState.utilityView.xAxis" @change="applyUtilityViewAxes()" title="X-Axis">
                        <template x-for="(name, idx) in (currentNegotiation?.negotiator_names || [])" :key="idx">
                            <option :value="idx" x-text="name.substring(0, 6)"></option>
                        </template>
                    </select>
                    <span style="font-size: 9px; opacity: 0.5;">×</span>
                    <select class="form-select form-select-xs" x-model.number="panelState.utilityView.yAxis" @change="applyUtilityViewAxes()" title="Y-Axis">
                        <template x-for="(name, idx) in (currentNegotiation?.negotiator_names || [])" :key="idx">
                            <option :value="idx" x-text="name.substring(0, 6)"></option>
                        </template>
                    </select>
                </div>
                <button class="panel-btn" title="Save as Image" @click="savePlot('outcome-space-plot', '2d-utility-view')" x-show="!panelCollapsed.utility2d">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                </button>
                <button class="panel-btn" title="Zoom" @click="zoomPanel('2D Utility View', 'outcome-space-plot')" x-show="!panelCollapsed.utility2d">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" y1="3" x2="14" y2="10"/><line x1="3" y1="21" x2="10" y2="14"/>
                    </svg>
                </button>
                <button class="panel-btn" title="Reset View" @click="resetPlotView()" x-show="!panelCollapsed.utility2d">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/>
                    </svg>
                </button>
                <button class="panel-btn panel-collapse-btn" title="Toggle panel" @click="panelCollapsed.utility2d = !panelCollapsed.utility2d">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </button>
            </div>
            <div class="panel-content panel-content-compact" style="padding: 0; position: relative;" x-show="!panelCollapsed.utility2d">
                <div id="outcome-space-plot" style="width: 100%; height: 100%;"></div>
                <div x-show="!currentNegotiation?.outcome_space_data" class="empty-state-mini" style="position: absolute; inset: 0; background: var(--bg-secondary);">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="width: 24px; height: 24px; opacity: 0.4;">
                        <circle cx="12" cy="12" r="10"/><path d="M8 12h8M12 8v8"/>
                    </svg>
                    <span class="text-muted">Loading...</span>
                </div>
            </div>
        </div>
        
        <!-- Resize handle between 2D Utility and Timeline -->
        <div class="resize-handle-horizontal" @mousedown="startPanelResize($event, 'utility2d-timeline')"></div>
        
        <!-- Utility Timeline Panel -->
        <div class="panel panel-compact panel-timeline" x-ref="panelTimeline" :class="{'collapsed': panelCollapsed.timeline}">
            <span class="panel-collapsed-label" x-show="panelCollapsed.timeline">TIMELINE</span>
            <div class="panel-floating-actions">
                <select class="form-select form-select-xs" x-show="currentNegotiation?.panelSettings?.adjustable && !panelCollapsed.timeline" x-model="panelState.timeline.xAxis" @change="initUtilityTimelinePlots()" title="X-Axis">
                    <option value="step">Step</option>
                    <option value="time">Time</option>
                    <option value="relative_time">Rel</option>
                </select>
                <button class="panel-btn" title="Save as Image" @click="savePlot('utility-timeline-container', 'utility-timeline')" x-show="!panelCollapsed.timeline">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                </button>
                <button class="panel-btn" title="Zoom" @click="zoomPanel('Utility Timeline', 'utility-timeline-container')" x-show="!panelCollapsed.timeline">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" y1="3" x2="14" y2="10"/><line x1="3" y1="21" x2="10" y2="14"/>
                    </svg>
                </button>
                <button class="panel-btn" title="Reset View" @click="resetTimelinePlotView()" x-show="!panelCollapsed.timeline">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/>
                    </svg>
                </button>
                <button class="panel-btn panel-collapse-btn" title="Toggle panel" @click="panelCollapsed.timeline = !panelCollapsed.timeline">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"></polyline></svg>
                </button>
            </div>
            <div class="panel-content panel-content-compact" style="padding: 0; position: relative;" x-show="!panelCollapsed.timeline">
                <div id="utility-timeline-container" style="width: 100%; height: 100%; overflow-y: auto; display: flex; flex-direction: column; gap: 2px; padding: 2px;"></div>
                <div x-show="!currentNegotiation?.offers || currentNegotiation.offers.length === 0" class="empty-state-mini" style="position: absolute; inset: 0; background: var(--bg-secondary);">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="width: 24px; height: 24px; opacity: 0.4;">
                        <polyline points="22 12 18 12 15 21 9 3 6 12 2 12"/>
                    </svg>
                    <span class="text-muted">Waiting...</span>
                </div>
            </div>
        </div>
        
        <!-- Issue Frequency Panel (hidden by default, ready for use) -->
        <div class="panel panel-compact panel-issue-freq" x-show="showIssueFrequency" style="display: none;">
            <div class="panel-floating-actions">
                <button class="panel-btn" title="Save as Image" @click="savePlot('issue-frequency-container', 'issue-frequency')">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/>
                    </svg>
                </button>
                <button class="panel-btn" title="Zoom" @click="zoomPanel('Issue Frequency', 'issue-frequency-container')">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="15 3 21 3 21 9"/><polyline points="9 21 3 21 3 15"/><line x1="21" y1="3" x2="14" y2="10"/><line x1="3" y1="21" x2="10" y2="14"/>
                    </svg>
                </button>
            </div>
            <div class="panel-content panel-content-compact" style="padding: 0; position: relative;">
                <div id="issue-frequency-container" style="width: 100%; height: 100%; overflow-y: auto; display: flex; flex-direction: column; gap: 2px; padding: 2px;"></div>
                <div x-show="!currentNegotiation?.offers || currentNegotiation.offers.length === 0" class="empty-state-mini" style="position: absolute; inset: 0; background: var(--bg-secondary);">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" style="width: 24px; height: 24px; opacity: 0.4;">
                        <rect x="3" y="3" width="18" height="18" rx="2"/><path d="M3 9h18M9 21V9"/>
                    </svg>
                    <span class="text-muted">Waiting...</span>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
// Extend the Alpine app with plotting functionality
document.addEventListener('alpine:init', () => {
    window.outcomeSpacePlotInitialized = false;
    window.timelinePlotsInitialized = false;
});

// Override/extend app functions for plotting
const originalApp = app;
app = function() {
    const base = originalApp();
    
    // Create extended object that properly inherits from base
    const extended = Object.create(base);
    
    // Color-blind friendly palette (Okabe-Ito)
    const COLORBLIND_COLORS = [
        '#0072B2',  // Blue
        '#E69F00',  // Orange
        '#009E73',  // Bluish Green
        '#CC79A7',  // Reddish Purple
        '#F0E442',  // Yellow
        '#56B4E9',  // Sky Blue
        '#D55E00',  // Vermillion
        '#000000',  // Black
    ];
    
    // Dark mode color-blind colors (brighter)
    const COLORBLIND_COLORS_DARK = [
        '#56B4E9',  // Sky Blue
        '#E69F00',  // Orange
        '#009E73',  // Bluish Green
        '#CC79A7',  // Reddish Purple
        '#F0E442',  // Yellow
        '#0072B2',  // Blue
        '#D55E00',  // Vermillion
        '#FFFFFF',  // White
    ];
    
    // Line dash patterns
    const LINE_DASHES = ['solid', 'dash', 'dot', 'dashdot', 'longdash', 'longdashdot'];
    
    // Marker symbols
    const MARKER_SYMBOLS = ['circle', 'square', 'diamond', 'cross', 'x', 'triangle-up', 'triangle-down', 'star'];
    
    // Add our custom properties/methods
    Object.assign(extended, {
        // Panel state for controls
        zoomedPanel: null,
        showIssueFrequency: false,  // Hidden feature for now
        showScenarioStatsModal: false,  // Stats modal visibility
        currentNegotiationStats: null,  // Stats for current negotiation's scenario
        currentNegotiationStatsLoading: false,
        currentNegotiationStatsError: null,
        panelState: {
            utilityView: { xAxis: 0, yAxis: 1 },
            timeline: { xAxis: 'relative_time' }
        },
        
        // Panel collapse state
        panelCollapsed: {
            info: false,
            history: false,
            result: false,
            utility2d: false,
            timeline: false
        },
        
        // Resize state
        resizeState: {
            active: false,
            type: null,  // 'column' or panel resize type
            startX: 0,
            startY: 0,
            startWidth: 0,
            startHeight: 0
        },
        
        // Saved negotiations state
        savedNegotiations: [],
        savedNegotiationsLoading: false,
        
        // Tabulator instances
        _runningTable: null,
        _completedTable: null,
        _savedTable: null,
        
        // Override init
        async init() {
            await base.init.call(this);
            
            // Load saved panel collapse state
            const savedCollapsed = localStorage.getItem('panelCollapsed');
            if (savedCollapsed) {
                try {
                    Object.assign(this.panelCollapsed, JSON.parse(savedCollapsed));
                } catch (e) {}
            }
            
            // Load saved column width
            const savedColumnWidth = localStorage.getItem('leftColumnWidth');
            if (savedColumnWidth) {
                this.$nextTick(() => {
                    const leftCol = this.$refs.leftColumn;
                    if (leftCol) {
                        leftCol.style.flex = `0 0 ${savedColumnWidth}`;
                    }
                });
            }
            
            // Add mouse move/up listeners for resize
            document.addEventListener('mousemove', this.handleResizeMove.bind(this));
            document.addEventListener('mouseup', this.handleResizeEnd.bind(this));
            
            // Watch for panel collapse changes and save to localStorage
            this.$watch('panelCollapsed', () => {
                localStorage.setItem('panelCollapsed', JSON.stringify(this.panelCollapsed));
            }, { deep: true });
            
            // Listen for theme changes to redraw charts
            window.addEventListener('colorblind-mode-changed', () => {
                if (this.currentNegotiation) {
                    this.$nextTick(() => {
                        this.initOutcomeSpacePlot();
                        this.initUtilityTimelinePlots();
                    });
                }
            });
            
            window.addEventListener('dark-mode-changed', () => {
                if (this.currentNegotiation) {
                    this.$nextTick(() => {
                        this.initOutcomeSpacePlot();
                        this.initUtilityTimelinePlots();
                    });
                }
            });
            
            // Watch for changes to negotiations arrays to update tables
            this.$watch('runningNegotiations', () => this.updateRunningTable(), { deep: true });
            this.$watch('completedNegotiations', () => this.updateCompletedTable(), { deep: true });
            this.$watch('savedNegotiations', () => this.updateSavedTable(), { deep: true });
        },
        
        // Initialize Tabulator tables for negotiations view
        initNegotiationsTables() {
            this.$nextTick(() => {
                this.initRunningTable();
                this.initCompletedTable();
                this.initSavedTable();
            });
        },
        
        // Helper to format negotiator badges HTML
        formatNegotiatorBadges(names, colors) {
            if (!names || names.length === 0) return '';
            return names.map((name, idx) => {
                const color = colors?.[idx] || 'var(--primary)';
                return `<span class="badge badge-sm" style="background: ${color}; color: white;">${name}</span>`;
            }).join(' ');
        },
        
        // Helper to format utilities HTML
        formatUtilities(utilities, colors) {
            if (!utilities || utilities.length === 0) return '<span class="text-muted">-</span>';
            return utilities.map((util, idx) => {
                const color = colors?.[idx] || 'inherit';
                return `<span style="color: ${color};">${util.toFixed(2)}</span>`;
            }).join(' ');
        },
        
        // Helper to format result badge
        formatResultBadge(neg) {
            if (neg.agreement) {
                return '<span class="badge badge-success">Agreement</span>';
            } else if (neg.error) {
                return '<span class="badge badge-danger">Error</span>';
            } else {
                return `<span class="badge badge-warning">${neg.end_reason || 'No Agreement'}</span>`;
            }
        },
        
        // Initialize running negotiations table
        initRunningTable() {
            const container = document.getElementById('running-negotiations-table');
            if (!container || this._runningTable) return;
            
            const self = this;
            this._runningTable = new Tabulator(container, {
                data: this.runningNegotiations,
                layout: "fitColumns",
                height: "auto",
                maxHeight: "200px",
                placeholder: "No running negotiations",
                columns: [
                    { title: "ID", field: "id", width: 100, formatter: (cell) => `<code>${cell.getValue()}</code>` },
                    { title: "Scenario", field: "scenario", formatter: (cell) => cell.getValue() || 'Loading...' },
                    { title: "Negotiators", field: "negotiator_names", formatter: (cell, params, onRendered) => {
                        const row = cell.getRow().getData();
                        return self.formatNegotiatorBadges(row.negotiator_names, row.negotiator_colors);
                    }, headerSort: false },
                    { title: "Progress", field: "relative_time", width: 150, formatter: (cell) => {
                        const row = cell.getRow().getData();
                        const progress = Math.min(100, (row.relative_time || 0) * 100);
                        return `<div style="display: flex; align-items: center; gap: 8px;">
                            <div class="progress" style="width: 80px; height: 6px;">
                                <div class="progress-bar" style="width: ${progress}%"></div>
                            </div>
                            <span style="font-size: 12px;">${row.step ? 'Step ' + row.step : 'Starting...'}</span>
                        </div>`;
                    }, headerSort: false },
                    { title: "Status", field: "paused", width: 100, formatter: (cell) => {
                        const paused = cell.getValue();
                        return `<span class="badge badge-primary">${paused ? 'Paused' : 'Running'}</span>`;
                    } }
                ],
                rowClick: (e, row) => {
                    self.selectNegotiation(row.getData());
                }
            });
        },
        
        // Initialize completed negotiations table
        initCompletedTable() {
            const container = document.getElementById('completed-negotiations-table');
            if (!container || this._completedTable) return;
            
            const self = this;
            this._completedTable = new Tabulator(container, {
                data: this.completedNegotiations,
                layout: "fitColumns",
                height: "auto",
                maxHeight: "300px",
                placeholder: "No completed negotiations",
                columns: [
                    { title: "ID", field: "id", width: 100, formatter: (cell) => `<code>${cell.getValue()}</code>` },
                    { title: "Scenario", field: "scenario", sorter: "string" },
                    { title: "Negotiators", field: "negotiator_names", formatter: (cell, params, onRendered) => {
                        const row = cell.getRow().getData();
                        return self.formatNegotiatorBadges(row.negotiator_names, row.negotiator_colors);
                    }, headerSort: false },
                    { title: "Steps", field: "step", width: 80, sorter: "number", formatter: (cell) => {
                        const row = cell.getRow().getData();
                        return row.step || row.offers?.length || '-';
                    } },
                    { title: "Result", field: "agreement", width: 120, formatter: (cell) => {
                        return self.formatResultBadge(cell.getRow().getData());
                    } },
                    { title: "Utilities", field: "final_utilities", formatter: (cell, params, onRendered) => {
                        const row = cell.getRow().getData();
                        return self.formatUtilities(row.final_utilities, row.negotiator_colors);
                    }, headerSort: false }
                ],
                rowClick: (e, row) => {
                    self.selectNegotiation(row.getData());
                }
            });
        },
        
        // Initialize saved negotiations table
        initSavedTable() {
            const container = document.getElementById('saved-negotiations-table');
            if (!container || this._savedTable) return;
            
            const self = this;
            this._savedTable = new Tabulator(container, {
                data: this.savedNegotiations,
                layout: "fitColumns",
                height: "auto",
                maxHeight: "300px",
                placeholder: "No saved negotiations",
                columns: [
                    { title: "ID", field: "id", width: 100, formatter: (cell) => `<code>${cell.getValue()}</code>` },
                    { title: "Scenario", field: "scenario_name", sorter: "string" },
                    { title: "Negotiators", field: "negotiator_names", formatter: (cell, params, onRendered) => {
                        const row = cell.getRow().getData();
                        return self.formatNegotiatorBadges(row.negotiator_names, row.negotiator_colors);
                    }, headerSort: false },
                    { title: "Mechanism", field: "mechanism_type", width: 120, sorter: "string" },
                    { title: "Steps", field: "current_step", width: 80, sorter: "number" },
                    { title: "Result", field: "agreement", width: 120, formatter: (cell) => {
                        const row = cell.getRow().getData();
                        if (row.agreement) {
                            return '<span class="badge badge-success">Agreement</span>';
                        } else if (row.error) {
                            return '<span class="badge badge-danger">Error</span>';
                        } else {
                            return `<span class="badge badge-warning">${row.end_reason || 'No Agreement'}</span>`;
                        }
                    } },
                    { title: "Date", field: "end_time", width: 120, sorter: "datetime", formatter: (cell) => {
                        const val = cell.getValue();
                        if (!val) return '-';
                        const date = new Date(val);
                        return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
                    } },
                    { title: "", width: 50, headerSort: false, formatter: () => {
                        return `<button class="btn btn-ghost btn-xs delete-btn" title="Delete">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="14" height="14">
                                <polyline points="3 6 5 6 21 6"></polyline>
                                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                            </svg>
                        </button>`;
                    }, cellClick: (e, cell) => {
                        e.stopPropagation();
                        const row = cell.getRow().getData();
                        self.deleteSavedNegotiation(row.id);
                    } }
                ],
                rowClick: (e, row) => {
                    // Don't trigger row click if clicking delete button
                    if (e.target.closest('.delete-btn')) return;
                    self.loadAndSelectSavedNegotiation(row.getData().id);
                }
            });
        },
        
        // Update running table data
        updateRunningTable() {
            if (this._runningTable) {
                this._runningTable.replaceData(this.runningNegotiations);
            }
        },
        
        // Update completed table data
        updateCompletedTable() {
            if (this._completedTable) {
                this._completedTable.replaceData(this.completedNegotiations);
            }
        },
        
        // Update saved table data
        updateSavedTable() {
            if (this._savedTable) {
                this._savedTable.replaceData(this.savedNegotiations);
            }
        },
        
        // Load saved negotiations from disk
        async loadSavedNegotiations() {
            this.savedNegotiationsLoading = true;
            try {
                const response = await fetch('/api/negotiation/saved/list');
                const data = await response.json();
                this.savedNegotiations = data.negotiations || [];
            } catch (e) {
                console.error('Failed to load saved negotiations:', e);
            } finally {
                this.savedNegotiationsLoading = false;
            }
        },
        
        // Load and select a saved negotiation
        async loadAndSelectSavedNegotiation(sessionId) {
            try {
                const response = await fetch(`/api/negotiation/saved/${sessionId}`);
                if (!response.ok) throw new Error('Failed to load negotiation');
                const negData = await response.json();
                
                // Transform to match our negotiation format
                const neg = {
                    id: negData.id,
                    scenario: negData.scenario_name,
                    scenario_path: negData.scenario_path,
                    mechanism_type: negData.mechanism_type,
                    negotiator_names: negData.negotiator_names,
                    negotiator_types: negData.negotiator_types,
                    negotiator_colors: negData.negotiator_colors,
                    issue_names: negData.issue_names,
                    step: negData.current_step,
                    n_steps: negData.n_steps,
                    time_limit: negData.time_limit,
                    offers: negData.offers || [],
                    outcome_space_data: negData.outcome_space_data,
                    agreement: negData.agreement,
                    final_utilities: negData.final_utilities,
                    end_reason: negData.end_reason,
                    error: negData.error,
                    start_time: negData.start_time,
                    end_time: negData.end_time,
                    // Mark as loaded from disk
                    _fromSaved: true
                };
                
                this.selectNegotiation(neg);
            } catch (e) {
                console.error('Failed to load saved negotiation:', e);
            }
        },
        
        // Delete a saved negotiation
        async deleteSavedNegotiation(sessionId) {
            if (!confirm('Delete this saved negotiation?')) return;
            
            try {
                await fetch(`/api/negotiation/saved/${sessionId}`, { method: 'DELETE' });
                this.savedNegotiations = this.savedNegotiations.filter(n => n.id !== sessionId);
            } catch (e) {
                console.error('Failed to delete negotiation:', e);
            }
        },
        
        // Clear all saved negotiations
        async clearSavedNegotiations() {
            if (!confirm('Delete ALL saved negotiations? This cannot be undone.')) return;
            
            try {
                await fetch('/api/negotiation/saved', { method: 'DELETE' });
                this.savedNegotiations = [];
            } catch (e) {
                console.error('Failed to clear negotiations:', e);
            }
        },
        
        // Get colors based on theme
        getPlotColors() {
            const isDark = document.documentElement.classList.contains('dark-mode') || 
                           document.body.classList.contains('dark-mode');
            return {
                textColor: isDark ? '#b6c2cf' : '#172b4d',
                gridColor: isDark ? '#38414a' : '#dfe1e6',
                bgColor: 'transparent',
                outcomeColor: isDark ? 'rgba(100, 120, 140, 0.3)' : 'rgba(100, 120, 140, 0.4)',
                // Use black/white for special points (not used for negotiators)
                specialPointColor: isDark ? '#ffffff' : '#000000',
                agreementColor: '#10b981'
            };
        },
        
        // Get negotiator colors - avoid black/white as they're used for special points
        getNegotiatorColors() {
            const neg = this.currentNegotiation;
            // Colors that avoid black/white (reserved for Pareto/Nash/Kalai/Welfare)
            const defaultColors = neg?.negotiator_colors || ['#4a6fa5', '#22a06b', '#e65100', '#7b1fa2', '#00695c', '#c62828', '#1565c0', '#6a1b9a'];
            const isColorBlind = document.documentElement.classList.contains('color-blind-mode');
            const isDark = document.documentElement.classList.contains('dark-mode');
            return isColorBlind ? (isDark ? COLORBLIND_COLORS_DARK : COLORBLIND_COLORS) : defaultColors;
        },
        
        // Calculate negotiation progress (0-1)
        // For TAU mechanism: max(relative_time, step/(n_outcomes+1))
        // For others: relative_time (falls back to step/n_steps if no relative_time)
        getNegotiationProgress(neg) {
            if (!neg) return 0;
            
            const relativeTime = neg.relative_time || 0;
            const step = neg.step || 0;
            const nSteps = neg.n_steps;
            const nOutcomes = neg.n_outcomes;
            const mechType = neg.mechanism_type || '';
            
            // For TAU mechanism: use max of relative_time and step-based progress
            if (mechType.includes('TAU') && nOutcomes && nOutcomes > 0) {
                const stepProgress = step / (nOutcomes + 1);
                return Math.min(1, Math.max(relativeTime, stepProgress));
            }
            
            // For other mechanisms: prefer relative_time, fallback to step/n_steps
            if (relativeTime > 0) {
                return Math.min(1, relativeTime);
            }
            
            // Fallback to step-based progress if n_steps is defined
            if (nSteps && nSteps > 0) {
                return Math.min(1, step / nSteps);
            }
            
            // No progress info available
            return 0;
        },
        
        // Save panel collapse state
        savePanelCollapsed() {
            localStorage.setItem('panelCollapsed', JSON.stringify(this.panelCollapsed));
        },
        
        // Column resize start
        startColumnResize(event) {
            event.preventDefault();
            const leftCol = this.$refs.leftColumn;
            if (!leftCol) return;
            
            this.resizeState = {
                active: true,
                type: 'column',
                startX: event.clientX,
                startY: 0,
                startWidth: leftCol.offsetWidth,
                startHeight: 0
            };
            
            this.$refs.columnResizer?.classList.add('dragging');
            document.body.style.cursor = 'col-resize';
            document.body.style.userSelect = 'none';
        },
        
        // Panel resize start
        startPanelResize(event, resizeType) {
            event.preventDefault();
            this.resizeState = {
                active: true,
                type: resizeType,
                startX: event.clientX,
                startY: event.clientY,
                startWidth: 0,
                startHeight: 0
            };
            
            // Store starting heights
            const panels = {
                'info-history': [this.$refs.panelInfo, this.$refs.panelHistory],
                'history-result': [this.$refs.panelHistory, this.$refs.panelResult],
                'utility2d-timeline': [this.$refs.panel2dUtility, this.$refs.panelTimeline]
            };
            
            const [panel1, panel2] = panels[resizeType] || [];
            if (panel1 && panel2) {
                this.resizeState.panel1Height = panel1.offsetHeight;
                this.resizeState.panel2Height = panel2.offsetHeight;
                this.resizeState.panel1 = panel1;
                this.resizeState.panel2 = panel2;
            }
            
            event.target.classList.add('dragging');
            document.body.style.cursor = 'row-resize';
            document.body.style.userSelect = 'none';
        },
        
        // Handle resize move
        handleResizeMove(event) {
            if (!this.resizeState.active) return;
            
            if (this.resizeState.type === 'column') {
                const delta = event.clientX - this.resizeState.startX;
                const newWidth = Math.max(200, Math.min(window.innerWidth * 0.7, this.resizeState.startWidth + delta));
                const leftCol = this.$refs.leftColumn;
                if (leftCol) {
                    leftCol.style.flex = `0 0 ${newWidth}px`;
                }
            } else if (this.resizeState.panel1 && this.resizeState.panel2) {
                const delta = event.clientY - this.resizeState.startY;
                const panel1 = this.resizeState.panel1;
                const panel2 = this.resizeState.panel2;
                
                const newHeight1 = Math.max(40, this.resizeState.panel1Height + delta);
                const newHeight2 = Math.max(40, this.resizeState.panel2Height - delta);
                
                // Use flex basis instead of fixed height for flexible panels
                const totalFlex = (newHeight1 + newHeight2) / 100;
                panel1.style.flex = `1 1 ${(newHeight1 / totalFlex)}%`;
                panel2.style.flex = `1 1 ${(newHeight2 / totalFlex)}%`;
            }
        },
        
        // Handle resize end
        handleResizeEnd() {
            if (!this.resizeState.active) return;
            
            // Save column width
            if (this.resizeState.type === 'column') {
                const leftCol = this.$refs.leftColumn;
                if (leftCol) {
                    localStorage.setItem('leftColumnWidth', leftCol.style.flex.replace('0 0 ', ''));
                }
            }
            
            // Remove dragging classes
            document.querySelectorAll('.dragging').forEach(el => el.classList.remove('dragging'));
            document.body.style.cursor = '';
            document.body.style.userSelect = '';
            
            this.resizeState = { active: false, type: null, startX: 0, startY: 0, startWidth: 0, startHeight: 0 };
            
            // Redraw plots after resize
            this.$nextTick(() => {
                if (this.currentNegotiation) {
                    this.initOutcomeSpacePlot();
                    this.initUtilityTimelinePlots();
                }
            });
        },
        
        // Apply utility view axis changes
        applyUtilityViewAxes() {
            window.outcomeSpacePlotInitialized = false;
            this.initOutcomeSpacePlot();
        },
        
        // Initialize outcome space plot (2D Utility View)
        async initOutcomeSpacePlot() {
            const plotDiv = document.getElementById('outcome-space-plot');
            if (!plotDiv) return;
            
            // Don't try to render if panel is collapsed or hidden
            if (plotDiv.offsetParent === null || plotDiv.clientWidth === 0) {
                window.outcomeSpacePlotInitialized = false;
                return;
            }
            
            const neg = this.currentNegotiation;
            if (!neg || !neg.outcome_space_data) {
                window.outcomeSpacePlotInitialized = false;
                return;
            }
            
            try {
                const colors = this.getPlotColors();
                const osd = neg.outcome_space_data;
                const negColors = this.getNegotiatorColors();
                const isColorBlind = document.documentElement.classList.contains('color-blind-mode');
            
            // Get axis indices from panel state
            const xIdx = this.panelState.utilityView.xAxis;
            const yIdx = this.panelState.utilityView.yAxis;
            
            const traces = [];
            
            // 1. All outcomes
            if (osd.outcome_utilities && osd.outcome_utilities.length > 0) {
                traces.push({
                    x: osd.outcome_utilities.map(u => u[xIdx] || 0),
                    y: osd.outcome_utilities.map(u => u[yIdx] || 0),
                    type: 'scatter',
                    mode: 'markers',
                    name: 'Outcomes',
                    marker: { color: colors.outcomeColor, size: 3, opacity: 0.5 },
                    hoverinfo: 'skip'
                });
            }
            
            // 2. Pareto frontier (markers only, no lines, using special point color)
            if (osd.pareto_utilities && osd.pareto_utilities.length > 0) {
                traces.push({
                    x: osd.pareto_utilities.map(u => u[xIdx] || 0),
                    y: osd.pareto_utilities.map(u => u[yIdx] || 0),
                    type: 'scatter',
                    mode: 'markers',
                    name: 'Pareto Frontier',
                    marker: { color: colors.specialPointColor, size: 6, opacity: 0.7 }
                });
            }
            
            // 3. Nash point (triangle-left marker)
            if (osd.nash_point && osd.nash_point.length > Math.max(xIdx, yIdx)) {
                traces.push({
                    x: [osd.nash_point[xIdx]],
                    y: [osd.nash_point[yIdx]],
                    type: 'scatter',
                    mode: 'markers',
                    name: 'Nash',
                    marker: { color: colors.specialPointColor, size: 14, symbol: 'triangle-left' }
                });
            }
            
            // 4. Kalai point (triangle-down marker)
            if (osd.kalai_point && osd.kalai_point.length > Math.max(xIdx, yIdx)) {
                traces.push({
                    x: [osd.kalai_point[xIdx]],
                    y: [osd.kalai_point[yIdx]],
                    type: 'scatter',
                    mode: 'markers',
                    name: 'Kalai',
                    marker: { color: colors.specialPointColor, size: 14, symbol: 'triangle-down' }
                });
            }
            
            // 5. Kalai-Smorodinsky point (triangle-up marker)
            if (osd.kalai_smorodinsky_point && osd.kalai_smorodinsky_point.length > Math.max(xIdx, yIdx)) {
                traces.push({
                    x: [osd.kalai_smorodinsky_point[xIdx]],
                    y: [osd.kalai_smorodinsky_point[yIdx]],
                    type: 'scatter',
                    mode: 'markers',
                    name: 'Kalai-Smorodinsky',
                    marker: { color: colors.specialPointColor, size: 14, symbol: 'triangle-up' }
                });
            }
            
            // 6. Max welfare point (triangle-right marker)
            if (osd.max_welfare_point && osd.max_welfare_point.length > Math.max(xIdx, yIdx)) {
                traces.push({
                    x: [osd.max_welfare_point[xIdx]],
                    y: [osd.max_welfare_point[yIdx]],
                    type: 'scatter',
                    mode: 'markers',
                    name: 'Max Welfare',
                    marker: { color: colors.specialPointColor, size: 14, symbol: 'triangle-right' }
                });
            }
            
            // 7. Offer traces per negotiator
            const offers = neg.offers || [];
            if (offers.length > 0) {
                const numAgents = neg.negotiator_names?.length || 2;
                for (let i = 0; i < numAgents; i++) {
                    // Use Number() for type coercion (proposer_index may be string or number from JSON)
                    const agentOffers = offers.filter(o => Number(o.proposer_index) === i);
                    if (agentOffers.length > 0) {
                        traces.push({
                            x: agentOffers.map(o => o.utilities[xIdx] || 0),
                            y: agentOffers.map(o => o.utilities[yIdx] || 0),
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: neg.negotiator_names?.[i] || `Agent ${i + 1}`,
                            line: { 
                                color: negColors[i % negColors.length], 
                                width: 2,
                                dash: isColorBlind ? LINE_DASHES[i % LINE_DASHES.length] : 'solid'
                            },
                            marker: { 
                                color: negColors[i % negColors.length], 
                                size: isColorBlind ? 8 : 6,
                                symbol: isColorBlind ? MARKER_SYMBOLS[i % MARKER_SYMBOLS.length] : 'circle'
                            }
                        });
                    }
                }
            }
            
            // 8. Agreement point
            if (neg.agreement && neg.final_utilities && neg.final_utilities.length > Math.max(xIdx, yIdx)) {
                traces.push({
                    x: [neg.final_utilities[xIdx]],
                    y: [neg.final_utilities[yIdx]],
                    type: 'scatter',
                    mode: 'markers',
                    name: 'Agreement',
                    marker: { color: colors.agreementColor, size: 16, symbol: 'star', line: { color: '#fff', width: 2 } }
                });
            }
            
            const layout = {
                xaxis: { 
                    title: { text: neg.negotiator_names?.[xIdx] || `Agent ${xIdx + 1}`, font: { color: colors.textColor } },
                    tickfont: { color: colors.textColor },
                    gridcolor: colors.gridColor,
                    linecolor: colors.gridColor,
                    zerolinecolor: colors.gridColor
                },
                yaxis: { 
                    title: { text: neg.negotiator_names?.[yIdx] || `Agent ${yIdx + 1}`, font: { color: colors.textColor } },
                    tickfont: { color: colors.textColor },
                    gridcolor: colors.gridColor,
                    linecolor: colors.gridColor,
                    zerolinecolor: colors.gridColor
                },
                margin: { t: 30, r: 30, b: 50, l: 50 },
                legend: { orientation: 'h', y: -0.15, font: { color: colors.textColor, size: 10 } },
                paper_bgcolor: colors.bgColor,
                plot_bgcolor: colors.bgColor,
                font: { family: '-apple-system, BlinkMacSystemFont, sans-serif', size: 11, color: colors.textColor }
            };
            
            const config = {
                responsive: true,
                displayModeBar: 'hover',
                modeBarButtonsToRemove: ['lasso2d', 'select2d'],
                toImageButtonOptions: { format: 'png', filename: '2d-utility-view', scale: 2 }
            };
            
                await Plotly.react(plotDiv, traces, layout, config);
                window.outcomeSpacePlotInitialized = true;
            } catch (e) {
                console.warn('Failed to initialize outcome space plot:', e);
                window.outcomeSpacePlotInitialized = false;
            }
        },
        
        // Update 2D plot with new offer
        async updateOutcomeSpacePlot(offer) {
            if (!window.outcomeSpacePlotInitialized) {
                await this.initOutcomeSpacePlot();
                return;
            }
            await this.initOutcomeSpacePlot();
        },
        
        resetPlotView() {
            const plotDiv = document.getElementById('outcome-space-plot');
            if (plotDiv) {
                Plotly.relayout(plotDiv, { 'xaxis.autorange': true, 'yaxis.autorange': true });
            }
        },
        
        // Initialize utility timeline plots - N plots for N negotiators
        async initUtilityTimelinePlots() {
            const container = document.getElementById('utility-timeline-container');
            if (!container) return;
            
            // Don't try to render if panel is collapsed or hidden
            if (container.offsetParent === null || container.clientWidth === 0) {
                window.timelinePlotsInitialized = false;
                return;
            }
            
            const neg = this.currentNegotiation;
            if (!neg || !neg.offers || neg.offers.length === 0) {
                container.innerHTML = '';
                window.timelinePlotsInitialized = false;
                return;
            }
            
            try {
                const colors = this.getPlotColors();
                const negColors = this.getNegotiatorColors();
                const numAgents = neg.negotiator_names?.length || 2;
                const isColorBlind = document.documentElement.classList.contains('color-blind-mode');
                const xAxisType = this.panelState.timeline.xAxis;
            
            // Get X values based on selected axis type
            const getXValue = (offer) => {
                switch (xAxisType) {
                    case 'time': return offer.time || 0;
                    case 'relative_time': return offer.relative_time || 0;
                    default: return offer.step;
                }
            };
            
            const xAxisTitle = xAxisType === 'time' ? 'Time (s)' : (xAxisType === 'relative_time' ? 'Relative Time' : 'Step');
            
            // Clear and rebuild container
            container.innerHTML = '';
            
            // Create N plots, one per negotiator
            for (let agentIdx = 0; agentIdx < numAgents; agentIdx++) {
                const plotId = `timeline-plot-${agentIdx}`;
                const plotWrapper = document.createElement('div');
                plotWrapper.style.cssText = 'flex: 1; min-height: 150px;';
                plotWrapper.innerHTML = `<div id="${plotId}" style="width: 100%; height: 100%;"></div>`;
                container.appendChild(plotWrapper);
                
                const traces = [];
                
                // Create N series per plot - each series j shows utility of offers from agent j for agent agentIdx
                for (let proposerIdx = 0; proposerIdx < numAgents; proposerIdx++) {
                    // Use Number() for type coercion (proposer_index may be string or number from JSON)
                    const proposerOffers = neg.offers.filter(o => Number(o.proposer_index) === proposerIdx);
                    if (proposerOffers.length === 0) continue;
                    
                    const xValues = proposerOffers.map(getXValue);
                    const yValues = proposerOffers.map(o => o.utilities[agentIdx] || 0);
                    
                    // Own offers get thick solid line, others get dashed
                    const isOwnOffers = proposerIdx === agentIdx;
                    
                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines',
                        name: neg.negotiator_names?.[proposerIdx] || `Agent ${proposerIdx + 1}`,
                        line: { 
                            color: negColors[proposerIdx % negColors.length], 
                            width: isOwnOffers ? 3 : 1.5,
                            dash: isOwnOffers ? 'solid' : LINE_DASHES[(proposerIdx + 1) % LINE_DASHES.length]
                        }
                    });
                }
                
                // Add agreement marker if exists
                if (neg.agreement && neg.final_utilities && neg.final_utilities.length > agentIdx) {
                    const lastOffer = neg.offers[neg.offers.length - 1];
                    traces.push({
                        x: [getXValue(lastOffer)],
                        y: [neg.final_utilities[agentIdx]],
                        type: 'scatter',
                        mode: 'markers',
                        name: 'Agreement',
                        showlegend: agentIdx === 0,
                        marker: { color: colors.agreementColor, size: 12, symbol: 'star', line: { color: '#fff', width: 1 } }
                    });
                }
                
                const layout = {
                    title: { 
                        text: `${neg.negotiator_names?.[agentIdx] || 'Agent ' + (agentIdx + 1)}'s Utility`,
                        font: { size: 12, color: colors.textColor }
                    },
                    xaxis: { 
                        title: { text: xAxisTitle, font: { color: colors.textColor, size: 10 } },
                        tickfont: { color: colors.textColor, size: 9 },
                        gridcolor: colors.gridColor,
                        linecolor: colors.gridColor
                    },
                    yaxis: { 
                        title: { text: 'Utility', font: { color: colors.textColor, size: 10 } },
                        tickfont: { color: colors.textColor, size: 9 },
                        gridcolor: colors.gridColor,
                        linecolor: colors.gridColor
                    },
                    margin: { t: 35, r: 20, b: 35, l: 40 },
                    legend: { orientation: 'h', y: -0.3, font: { color: colors.textColor, size: 9 } },
                    paper_bgcolor: colors.bgColor,
                    plot_bgcolor: colors.bgColor,
                    font: { family: '-apple-system, BlinkMacSystemFont, sans-serif', size: 10, color: colors.textColor }
                };
                
                const config = {
                    responsive: true,
                    displayModeBar: 'hover',
                    modeBarButtonsToRemove: ['lasso2d', 'select2d'],
                    toImageButtonOptions: { format: 'png', filename: `utility-timeline-${agentIdx}`, scale: 2 }
                };
                
                await Plotly.newPlot(plotId, traces, layout, config);
            }
            
                window.timelinePlotsInitialized = true;
            } catch (e) {
                console.warn('Failed to initialize timeline plots:', e);
                window.timelinePlotsInitialized = false;
            }
        },
        
        async updateUtilityTimelinePlots(offer) {
            if (!window.timelinePlotsInitialized) {
                await this.initUtilityTimelinePlots();
                return;
            }
            await this.initUtilityTimelinePlots();
        },
        
        resetTimelinePlotView() {
            const neg = this.currentNegotiation;
            if (!neg) return;
            const numAgents = neg.negotiator_names?.length || 2;
            for (let i = 0; i < numAgents; i++) {
                const plotDiv = document.getElementById(`timeline-plot-${i}`);
                if (plotDiv) {
                    Plotly.relayout(plotDiv, { 'xaxis.autorange': true, 'yaxis.autorange': true });
                }
            }
        },
        
        // Zoom panel
        zoomPanel(panelName, plotId) {
            this.zoomedPanel = panelName;
            if (plotId) {
                this.$nextTick(() => {
                    // Render the plot to the zoomed container
                    const zoomedContainerId = 'zoomed-' + panelName.replace(/\s+/g, '-').toLowerCase();
                    const zoomedContainer = document.getElementById(zoomedContainerId);
                    if (zoomedContainer) {
                        if (plotId === 'outcome-space-plot') {
                            this.initOutcomeSpacePlotToElement(zoomedContainerId);
                        } else if (plotId === 'utility-timeline-container') {
                            this.initUtilityTimelinePlotsToElement(zoomedContainerId);
                        }
                    }
                });
            }
        },
        
        // Load stats for current negotiation's scenario
        async loadCurrentNegotiationStats() {
            const neg = this.currentNegotiation;
            if (!neg || !neg.scenario_path) {
                this.currentNegotiationStatsError = 'No scenario path available';
                return;
            }
            
            this.currentNegotiationStatsLoading = true;
            this.currentNegotiationStatsError = null;
            
            try {
                const res = await fetch(`/api/scenarios/${encodeURIComponent(neg.scenario_path)}/stats`);
                if (!res.ok) throw new Error('Failed to load stats');
                this.currentNegotiationStats = await res.json();
            } catch (e) {
                console.error('Failed to load negotiation stats:', e);
                this.currentNegotiationStatsError = 'Failed to load stats';
            } finally {
                this.currentNegotiationStatsLoading = false;
            }
        },
        
        // Calculate stats for current negotiation's scenario
        async calculateCurrentNegotiationStats(force = false) {
            const neg = this.currentNegotiation;
            if (!neg || !neg.scenario_path) {
                this.currentNegotiationStatsError = 'No scenario path available';
                return;
            }
            
            this.currentNegotiationStatsLoading = true;
            this.currentNegotiationStatsError = null;
            
            try {
                const res = await fetch(`/api/scenarios/${encodeURIComponent(neg.scenario_path)}/stats/calculate?force=${force}`, {
                    method: 'POST'
                });
                if (!res.ok) throw new Error('Failed to calculate stats');
                this.currentNegotiationStats = await res.json();
            } catch (e) {
                console.error('Failed to calculate negotiation stats:', e);
                this.currentNegotiationStatsError = 'Failed to calculate stats';
            } finally {
                this.currentNegotiationStatsLoading = false;
            }
        },
        
        // Initialize outcome space plot to a specific element (for zoom)
        async initOutcomeSpacePlotToElement(elementId) {
            const plotDiv = document.getElementById(elementId);
            if (!plotDiv) return;
            
            const neg = this.currentNegotiation;
            if (!neg || !neg.outcome_space_data) return;
            
            const colors = this.getPlotColors();
            const osd = neg.outcome_space_data;
            const negColors = this.getNegotiatorColors();
            const isColorBlind = document.documentElement.classList.contains('color-blind-mode');
            
            // Get axis indices from panel state
            const xIdx = this.panelState.utilityView.xAxis;
            const yIdx = this.panelState.utilityView.yAxis;
            
            const traces = [];
            
            // 1. All outcomes
            if (osd.outcome_utilities && osd.outcome_utilities.length > 0) {
                traces.push({
                    x: osd.outcome_utilities.map(u => u[xIdx] || 0),
                    y: osd.outcome_utilities.map(u => u[yIdx] || 0),
                    type: 'scatter',
                    mode: 'markers',
                    name: 'Outcomes',
                    marker: { color: colors.outcomeColor, size: 4, opacity: 0.5 },
                    hoverinfo: 'skip'
                });
            }
            
            // 2. Pareto frontier (markers only, no lines, using special point color)
            if (osd.pareto_utilities && osd.pareto_utilities.length > 0) {
                traces.push({
                    x: osd.pareto_utilities.map(u => u[xIdx] || 0),
                    y: osd.pareto_utilities.map(u => u[yIdx] || 0),
                    type: 'scatter',
                    mode: 'markers',
                    name: 'Pareto Frontier',
                    marker: { color: colors.specialPointColor, size: 7, opacity: 0.7 }
                });
            }
            
            // 3. Nash point (triangle-left marker)
            if (osd.nash_point && osd.nash_point.length > Math.max(xIdx, yIdx)) {
                traces.push({
                    x: [osd.nash_point[xIdx]],
                    y: [osd.nash_point[yIdx]],
                    type: 'scatter',
                    mode: 'markers',
                    name: 'Nash',
                    marker: { color: colors.specialPointColor, size: 16, symbol: 'triangle-left' }
                });
            }
            
            // 4. Kalai point (triangle-down marker)
            if (osd.kalai_point && osd.kalai_point.length > Math.max(xIdx, yIdx)) {
                traces.push({
                    x: [osd.kalai_point[xIdx]],
                    y: [osd.kalai_point[yIdx]],
                    type: 'scatter',
                    mode: 'markers',
                    name: 'Kalai',
                    marker: { color: colors.specialPointColor, size: 16, symbol: 'triangle-down' }
                });
            }
            
            // 5. Kalai-Smorodinsky point (triangle-up marker)
            if (osd.kalai_smorodinsky_point && osd.kalai_smorodinsky_point.length > Math.max(xIdx, yIdx)) {
                traces.push({
                    x: [osd.kalai_smorodinsky_point[xIdx]],
                    y: [osd.kalai_smorodinsky_point[yIdx]],
                    type: 'scatter',
                    mode: 'markers',
                    name: 'Kalai-Smorodinsky',
                    marker: { color: colors.specialPointColor, size: 16, symbol: 'triangle-up' }
                });
            }
            
            // 6. Max welfare point (triangle-right marker)
            if (osd.max_welfare_point && osd.max_welfare_point.length > Math.max(xIdx, yIdx)) {
                traces.push({
                    x: [osd.max_welfare_point[xIdx]],
                    y: [osd.max_welfare_point[yIdx]],
                    type: 'scatter',
                    mode: 'markers',
                    name: 'Max Welfare',
                    marker: { color: colors.specialPointColor, size: 16, symbol: 'triangle-right' }
                });
            }
            
            // 7. Offer traces per negotiator
            const offers = neg.offers || [];
            if (offers.length > 0) {
                const numAgents = neg.negotiator_names?.length || 2;
                for (let i = 0; i < numAgents; i++) {
                    // Use Number() for type coercion (proposer_index may be string or number from JSON)
                    const agentOffers = offers.filter(o => Number(o.proposer_index) === i);
                    if (agentOffers.length > 0) {
                        traces.push({
                            x: agentOffers.map(o => o.utilities[xIdx] || 0),
                            y: agentOffers.map(o => o.utilities[yIdx] || 0),
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: neg.negotiator_names?.[i] || `Agent ${i + 1}`,
                            line: { 
                                color: negColors[i % negColors.length], 
                                width: 2,
                                dash: isColorBlind ? LINE_DASHES[i % LINE_DASHES.length] : 'solid'
                            },
                            marker: { 
                                color: negColors[i % negColors.length], 
                                size: isColorBlind ? 10 : 8,
                                symbol: isColorBlind ? MARKER_SYMBOLS[i % MARKER_SYMBOLS.length] : 'circle'
                            }
                        });
                    }
                }
            }
            
            // 8. Agreement point
            if (neg.agreement && neg.final_utilities && neg.final_utilities.length > Math.max(xIdx, yIdx)) {
                traces.push({
                    x: [neg.final_utilities[xIdx]],
                    y: [neg.final_utilities[yIdx]],
                    type: 'scatter',
                    mode: 'markers',
                    name: 'Agreement',
                    marker: { color: colors.agreementColor, size: 18, symbol: 'star', line: { color: '#fff', width: 2 } }
                });
            }
            
            const layout = {
                xaxis: { 
                    title: { text: neg.negotiator_names?.[xIdx] || `Agent ${xIdx + 1}`, font: { color: colors.textColor, size: 14 } },
                    tickfont: { color: colors.textColor, size: 12 },
                    gridcolor: colors.gridColor,
                    linecolor: colors.gridColor,
                    zerolinecolor: colors.gridColor
                },
                yaxis: { 
                    title: { text: neg.negotiator_names?.[yIdx] || `Agent ${yIdx + 1}`, font: { color: colors.textColor, size: 14 } },
                    tickfont: { color: colors.textColor, size: 12 },
                    gridcolor: colors.gridColor,
                    linecolor: colors.gridColor,
                    zerolinecolor: colors.gridColor
                },
                margin: { t: 40, r: 40, b: 60, l: 60 },
                legend: { orientation: 'h', y: -0.12, font: { color: colors.textColor, size: 12 } },
                paper_bgcolor: colors.bgColor,
                plot_bgcolor: colors.bgColor,
                font: { family: '-apple-system, BlinkMacSystemFont, sans-serif', size: 13, color: colors.textColor }
            };
            
            const config = {
                responsive: true,
                displayModeBar: 'hover',
                modeBarButtonsToRemove: ['lasso2d', 'select2d'],
                toImageButtonOptions: { format: 'png', filename: '2d-utility-view-zoomed', scale: 2 }
            };
            
            await Plotly.newPlot(plotDiv, traces, layout, config);
        },
        
        // Initialize utility timeline plots to a specific element (for zoom)
        async initUtilityTimelinePlotsToElement(elementId) {
            const container = document.getElementById(elementId);
            if (!container) return;
            
            const neg = this.currentNegotiation;
            if (!neg || !neg.offers || neg.offers.length === 0) {
                container.innerHTML = '';
                return;
            }
            
            const colors = this.getPlotColors();
            const negColors = this.getNegotiatorColors();
            const numAgents = neg.negotiator_names?.length || 2;
            const isColorBlind = document.documentElement.classList.contains('color-blind-mode');
            const xAxisType = this.panelState.timeline.xAxis;
            
            // Get X values based on selected axis type
            const getXValue = (offer) => {
                switch (xAxisType) {
                    case 'time': return offer.time || 0;
                    case 'relative_time': return offer.relative_time || 0;
                    default: return offer.step;
                }
            };
            
            const xAxisTitle = xAxisType === 'time' ? 'Time (s)' : (xAxisType === 'relative_time' ? 'Relative Time' : 'Step');
            
            // Clear and rebuild container
            container.innerHTML = '';
            
            // Create N plots, one per negotiator
            for (let agentIdx = 0; agentIdx < numAgents; agentIdx++) {
                const plotId = `zoomed-timeline-plot-${agentIdx}`;
                const plotWrapper = document.createElement('div');
                plotWrapper.style.cssText = 'flex: 1; min-height: 200px;';
                plotWrapper.innerHTML = `<div id="${plotId}" style="width: 100%; height: 100%;"></div>`;
                container.appendChild(plotWrapper);
                
                const traces = [];
                
                // Create N series per plot - each series j shows utility of offers from agent j for agent agentIdx
                for (let proposerIdx = 0; proposerIdx < numAgents; proposerIdx++) {
                    // Use Number() for type coercion (proposer_index may be string or number from JSON)
                    const proposerOffers = neg.offers.filter(o => Number(o.proposer_index) === proposerIdx);
                    if (proposerOffers.length === 0) continue;
                    
                    const xValues = proposerOffers.map(getXValue);
                    const yValues = proposerOffers.map(o => o.utilities[agentIdx] || 0);
                    
                    // Own offers get thick solid line, others get dashed
                    const isOwnOffers = proposerIdx === agentIdx;
                    
                    traces.push({
                        x: xValues,
                        y: yValues,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: neg.negotiator_names?.[proposerIdx] || `Agent ${proposerIdx + 1}`,
                        line: { 
                            color: negColors[proposerIdx % negColors.length], 
                            width: isOwnOffers ? 3 : 2,
                            dash: isOwnOffers ? 'solid' : LINE_DASHES[(proposerIdx + 1) % LINE_DASHES.length]
                        },
                        marker: { 
                            color: negColors[proposerIdx % negColors.length], 
                            size: isOwnOffers ? 10 : 6,
                            symbol: isColorBlind ? MARKER_SYMBOLS[proposerIdx % MARKER_SYMBOLS.length] : 'circle'
                        }
                    });
                }
                
                // Add agreement marker if exists
                if (neg.agreement && neg.final_utilities && neg.final_utilities.length > agentIdx) {
                    const lastOffer = neg.offers[neg.offers.length - 1];
                    traces.push({
                        x: [getXValue(lastOffer)],
                        y: [neg.final_utilities[agentIdx]],
                        type: 'scatter',
                        mode: 'markers',
                        name: 'Agreement',
                        showlegend: agentIdx === 0,
                        marker: { color: colors.agreementColor, size: 14, symbol: 'star', line: { color: '#fff', width: 1 } }
                    });
                }
                
                const layout = {
                    title: { 
                        text: `${neg.negotiator_names?.[agentIdx] || 'Agent ' + (agentIdx + 1)}'s Utility`,
                        font: { size: 14, color: colors.textColor }
                    },
                    xaxis: { 
                        title: { text: xAxisTitle, font: { color: colors.textColor, size: 12 } },
                        tickfont: { color: colors.textColor, size: 11 },
                        gridcolor: colors.gridColor,
                        linecolor: colors.gridColor
                    },
                    yaxis: { 
                        title: { text: 'Utility', font: { color: colors.textColor, size: 12 } },
                        tickfont: { color: colors.textColor, size: 11 },
                        gridcolor: colors.gridColor,
                        linecolor: colors.gridColor
                    },
                    margin: { t: 45, r: 30, b: 45, l: 50 },
                    legend: { orientation: 'h', y: -0.25, font: { color: colors.textColor, size: 11 } },
                    paper_bgcolor: colors.bgColor,
                    plot_bgcolor: colors.bgColor,
                    font: { family: '-apple-system, BlinkMacSystemFont, sans-serif', size: 12, color: colors.textColor }
                };
                
                const config = {
                    responsive: true,
                    displayModeBar: 'hover',
                    modeBarButtonsToRemove: ['lasso2d', 'select2d'],
                    toImageButtonOptions: { format: 'png', filename: `utility-timeline-${agentIdx}-zoomed`, scale: 2 }
                };
                
                await Plotly.newPlot(plotId, traces, layout, config);
            }
        },
        
        // Save plot as image
        savePlot(plotId, filename) {
            const plotDiv = document.getElementById(plotId);
            if (plotDiv) {
                Plotly.downloadImage(plotDiv, { format: 'png', filename: filename, scale: 2 });
            }
        },
        
        // Save offers as JSON
        saveOffersAsJson() {
            const neg = this.currentNegotiation;
            if (!neg || !neg.offers) return;
            
            const data = {
                scenario: neg.scenario,
                negotiators: neg.negotiator_names,
                offers: neg.offers,
                agreement: neg.agreement,
                final_utilities: neg.final_utilities
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `negotiation-${neg.id}.json`;
            a.click();
            URL.revokeObjectURL(url);
        },
        
        // Save results
        saveResults() {
            this.saveOffersAsJson();
        },
        
        // Override connectToStream to handle init event and plotting
        connectToStream(sessionId, url, autoStart = true) {
            const eventSource = new EventSource(url);
            
            const neg = this.runningNegotiations.find(n => n.id === sessionId);
            if (neg) {
                neg.offers = [];
                neg.pendingStart = !autoStart;
                neg.panelSettings = neg.panelSettings || { adjustable: true };
            }
            
            eventSource.addEventListener('init', (event) => {
                const initData = JSON.parse(event.data);
                const neg = this.runningNegotiations.find(n => n.id === sessionId);
                if (neg) {
                    neg.negotiator_names = initData.negotiator_names;
                    neg.negotiator_types = initData.negotiator_types;
                    neg.negotiator_colors = initData.negotiator_colors;
                    neg.issue_names = initData.issue_names;
                    neg.n_steps = initData.n_steps;
                    neg.time_limit = initData.time_limit;
                    neg.n_outcomes = initData.n_outcomes;
                    neg.outcome_space_data = initData.outcome_space_data;
                    neg.scenario = initData.scenario_name;
                    neg.scenario_path = initData.scenario_path;
                    
                    // Initialize panel state for this negotiation
                    const numAgents = neg.negotiator_names?.length || 2;
                    this.panelState.utilityView.xAxis = neg.panelSettings?.utilityView?.xAxis ?? 0;
                    this.panelState.utilityView.yAxis = neg.panelSettings?.utilityView?.yAxis ?? Math.min(1, numAgents - 1);
                    this.panelState.timeline.xAxis = neg.panelSettings?.timeline?.xAxis ?? 'relative_time';
                    
                    if (this.currentNegotiation?.id === sessionId) {
                        this.currentNegotiation = neg;
                        this.$nextTick(() => {
                            this.initOutcomeSpacePlot();
                        });
                    }
                }
            });
            
            eventSource.addEventListener('offer', (event) => {
                const offer = JSON.parse(event.data);
                const neg = this.runningNegotiations.find(n => n.id === sessionId);
                if (neg) {
                    neg.step = offer.step;
                    neg.relative_time = offer.relative_time;
                    neg.lastOffer = offer;
                    neg.offers = neg.offers || [];
                    neg.offers.push(offer);
                    neg.pendingStart = false;
                    
                    // Force reactivity by updating currentNegotiation properties directly
                    if (this.currentNegotiation?.id === sessionId) {
                        this.currentNegotiation.step = neg.step;
                        this.currentNegotiation.relative_time = neg.relative_time;
                        this.currentNegotiation.lastOffer = neg.lastOffer;
                        this.currentNegotiation.offers = [...neg.offers];  // New array reference
                        this.currentNegotiation.pendingStart = false;
                        
                        this.updateOutcomeSpacePlot(offer);
                        this.updateUtilityTimelinePlots(offer);
                        
                        this.$nextTick(() => {
                            const log = this.$refs.offerLog;
                            if (log) log.scrollTop = log.scrollHeight;
                        });
                    }
                }
            });
            
            eventSource.addEventListener('complete', (event) => {
                const result = JSON.parse(event.data);
                const idx = this.runningNegotiations.findIndex(n => n.id === sessionId);
                if (idx >= 0) {
                    const neg = this.runningNegotiations.splice(idx, 1)[0];
                    neg.agreement = result.agreement;
                    neg.final_utilities = result.final_utilities;
                    // Always set end_reason for completed negotiations
                    neg.end_reason = result.end_reason || (result.error ? 'error' : (result.agreement ? 'agreement' : 'completed'));
                    neg.error = result.error;
                    neg.step = result.n_steps;
                    neg.pendingStart = false;
                    this.completedNegotiations.unshift(neg);
                    
                    if (this.currentNegotiation?.id === sessionId) {
                        this.currentNegotiation = neg;
                        this.$nextTick(() => {
                            this.initOutcomeSpacePlot();
                            this.initUtilityTimelinePlots();
                        });
                    }
                }
                eventSource.close();
            });
            
            eventSource.addEventListener('error', () => {
                eventSource.close();
            });
            
            if (neg) {
                this.currentNegotiation = neg;
            }
            
            // Store eventSource reference for manual start
            if (neg) {
                neg._eventSource = eventSource;
            }
        },
        
        // Actually start a pending negotiation
        async actuallyStartNegotiation() {
            const neg = this.currentNegotiation;
            if (!neg || !neg.pendingStart) return;
            
            try {
                await fetch(`/api/negotiation/${neg.id}/start`, { method: 'POST' });
                neg.pendingStart = false;
            } catch (e) {
                console.error('Failed to start negotiation:', e);
            }
        },
        
        // Override selectNegotiation to init plots
        selectNegotiation(neg) {
            this.currentNegotiation = neg;
            
            // Update panel state from negotiation settings
            const numAgents = neg.negotiator_names?.length || 2;
            this.panelState.utilityView.xAxis = neg.panelSettings?.utilityView?.xAxis ?? 0;
            this.panelState.utilityView.yAxis = neg.panelSettings?.utilityView?.yAxis ?? Math.min(1, numAgents - 1);
            this.panelState.timeline.xAxis = neg.panelSettings?.timeline?.xAxis ?? 'step';
            
            window.outcomeSpacePlotInitialized = false;
            window.timelinePlotsInitialized = false;
            this.$nextTick(() => {
                this.initOutcomeSpacePlot();
                this.initUtilityTimelinePlots();
            });
        },
        
        // Toggle pause state
        async togglePause() {
            if (!this.currentNegotiation) return;
            const sessionId = this.currentNegotiation.id;
            const isPaused = this.currentNegotiation.paused;
            
            try {
                const endpoint = isPaused ? 'resume' : 'pause';
                await fetch(`/api/negotiation/${sessionId}/${endpoint}`, { method: 'POST' });
                this.currentNegotiation.paused = !isPaused;
            } catch (e) {
                console.error('Failed to toggle pause:', e);
            }
        },
        
        // Cancel the current negotiation
        async stopNegotiation() {
            if (!this.currentNegotiation) return;
            const sessionId = this.currentNegotiation.id;
            try {
                await fetch(`/api/negotiation/${sessionId}/cancel`, { method: 'POST' });
            } catch (e) {
                console.error('Failed to cancel negotiation:', e);
            }
        }
    });
    
    return extended;
};
</script>
{% endblock %}
