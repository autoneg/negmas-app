<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{% block title %}NegMAS App{% endblock %}</title>
    
    <!-- Styles -->
    <link rel="stylesheet" href="/static/css/styles.css">
    
    <!-- Apply dark mode immediately to prevent flash -->
    <script>
        if (localStorage.getItem('darkMode') === 'true') {
            document.documentElement.classList.add('dark-mode');
        }
        if (localStorage.getItem('colorBlindMode') === 'true') {
            document.documentElement.classList.add('color-blind-mode');
        }
    </script>
    
    <!-- HTMX -->
    <script src="https://unpkg.com/htmx.org@1.9.10"></script>
    <script src="https://unpkg.com/htmx.org@1.9.10/dist/ext/sse.js"></script>
    
    <!-- Alpine.js Collapse Plugin -->
    <script defer src="https://unpkg.com/@alpinejs/collapse@3.x.x/dist/cdn.min.js"></script>
    
    <!-- Alpine.js -->
    <script defer src="https://unpkg.com/alpinejs@3.x.x/dist/cdn.min.js"></script>
    
    <!-- SortableJS for drag-reorder -->
    <script src="https://unpkg.com/sortablejs@1.15.0/Sortable.min.js"></script>
    
    <!-- Plotly.js for real-time plotting -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js" charset="utf-8"></script>
    
    <!-- Tabulator for data tables - using simple theme, colors overridden in styles.css -->
    <link href="https://unpkg.com/tabulator-tables@6.2.5/dist/css/tabulator_simple.min.css" rel="stylesheet">
    <script src="https://unpkg.com/tabulator-tables@6.2.5/dist/js/tabulator.min.js"></script>
    
    <!-- Layout System -->
    <link rel="stylesheet" href="/static/css/layout.css">
    <script src="/static/js/panel-registry.js"></script>
    <script src="/static/js/layout-manager.js"></script>
    <script src="/static/js/layout-renderer.js"></script>
    
    {% block head %}{% endblock %}
</head>
<body x-data="app()" x-init="init()">
    {% include 'components/shared/toast.html' %}
    
    <div class="app-container">
        {% include 'components/shared/header.html' %}
        
        <!-- Main Layout -->
        <div class="main-layout">
            {% include 'components/shared/sidebar.html' %}
            
            <!-- Content Area - Negotiations -->
            <main class="content-area" x-show="currentPage === 'negotiations'">
                {% include 'components/pages/negotiations_list_page.html' %}
                {% include 'components/pages/negotiation_view_page.html' %}
            </main>
            
            {% include 'components/pages/scenarios_page.html' %}
            
            {% include 'components/pages/negotiators_page.html' %}
            
            <!-- Content Area - Tournaments -->
            <div class="content-area tournament-page" x-show="currentPage === 'tournaments'" x-cloak>
                {% include 'components/pages/tournaments_list_page.html' %}
                {% include 'components/pages/tournament_view_page.html' %}
            </div>
        </div>
    </div>
    
    {% include 'components/modals/new_negotiation_modal.html' %}

    {% include 'components/modals/negotiator_config_modal.html' %}

    {% include 'components/modals/tournament_competitor_config_modal.html' %}

    {% include 'components/modals/save_virtual_mechanism_modal.html' %}

    {% include 'components/modals/new_tournament_modal.html' %}

    {% include 'components/modals/settings_modal.html' %}

    {% include 'components/modals/save_session_modal.html' %}

    {% include 'components/modals/scenario_creator_modal.html' %}

    {% include 'components/modals/load_negotiation_modal.html' %}

    <script>
    function app() {
        return {
            // Connection status
            connected: true,
            
            // Global loading states
            scenariosLoading: false,
            negotiatorsLoading: false,
            
            // Toast notification state
            toastMessage: '',
            toastType: 'success',
            toastVisible: false,
            
            // Sidebar state - collapsed by default unless user explicitly opened it
            sidebarCollapsed: localStorage.getItem('sidebarCollapsed') !== 'false',
            
            // Modal states
            showNewNegotiation: false,
            showSettings: false,
            showNegotiatorConfig: false,
            showLoadNegotiation: false,
            loadNegotiationPath: '',
            loadNegotiationLoading: false,
            loadNegotiationError: null,
            
            // Negotiator configuration modal state
            configNegotiatorIndex: null,  // Index of negotiator being configured
            configNegotiatorParams: [],   // Parameters from API
            configNegotiatorValues: {},   // Current values being edited
            configNegotiatorLoading: false,
            
            // Page state (negotiations, scenarios, tournaments)
            currentPage: 'negotiations',
            
            // Tournament state
            showNewTournament: false,
            
            // Scenario Creator state
            showScenarioCreator: false,
            scenarioCreator: {
                name: '',
                issues: [],
                ufuns: [],
                error: null,
                creating: false,
            },
            
            tournamentSessions: [],
            savedTournaments: [],
            savedTournamentsLoading: false,
            selectedTournament: null,
            tournamentEventSource: null,
            // Tournament list state (for Tabulator tables)
            runningTournaments: [],
            completedTournaments: [],
            showArchivedTournaments: false,
            tournamentTagFilter: '',
            availableTournamentTags: [],
            // Loading states
            loadingTraceIndex: null,  // Index of negotiation being loaded, null if not loading
            // Tournament panel collapse state
            tournamentPanelCollapsed: {
                grid: false,
                scores: false,
                negotiations: true,  // Start collapsed
                savedConfig: false,  // For saved tournament config panel
                savedScores: false,  // For saved tournament scores panel
                savedNegotiations: true,  // Start collapsed
                rawData: true,  // For raw data panel (collapsed by default)
                scoreAnalysis: false,  // For score analysis panel
            },
            // Score Analysis state (for saved tournaments)
            scoreAnalysis: {
                loading: false,
                data: null,  // Leaderboard, available metrics/stats
                metric: 'utility',
                statistic: 'mean',
                scenario: '',  // '' means all scenarios
                partner: '',  // '' means all partners
            },
            // Tournament raw data (loaded on-demand for saved tournaments)
            tournamentRawData: {
                loading: false,
                config: null,
                typeScores: null,
                allScores: null,
                details: null,
                files: null,
                activeTab: 'config',  // 'config', 'type_scores', 'all_scores', 'details'
            },
            // Tournament grid visualization state
            tournamentGrid: {
                competitors: [],
                opponents: [],
                scenarios: [],
                cells: {},  // Key: `${competitorIdx}-${opponentIdx}-${scenarioIdx}-${rep}-${rotated}` -> { status, end_reason, utilities }
                currentTab: 'summary',  // 'summary' or scenario index
                n_repetitions: 1,
                rotate_ufuns: false,
            },
            tournamentSetupProgress: null,  // { message, current, total } for setup progress before negotiations start
            tournamentLeaderboard: [],
            tournamentLiveNegotiations: [],  // Negotiations that complete during running tournament
            newTournament: {
                competitor_types: [],
                opponent_types: [],
                opponents_same_as_competitors: true,  // When true, opponents = null (competitors play each other)
                scenario_paths: [],
                n_repetitions: 1,
                rotate_ufuns: true,
                self_play: true,
                mechanism_type: 'SAOMechanism',
                n_steps: 100,
                n_steps_range_enabled: false,
                n_steps_min: 50,
                n_steps_max: 200,
                time_limit: null,
                time_limit_range_enabled: false,
                time_limit_min: 30,
                time_limit_max: 120,
                // Time limits for negotiators
                step_time_limit: null,
                negotiator_time_limit: null,
                hidden_time_limit: null,
                // Probabilistic ending
                pend: null,
                pend_per_second: null,
                // Scoring
                final_score_metric: 'advantage',
                final_score_stat: 'mean',
                // Run ordering
                randomize_runs: false,
                sort_runs: true,
                // Information hiding
                id_reveals_type: false,
                name_reveals_type: true,
                mask_scenario_names: false,
                // Self-play options
                only_failures_on_self_play: false,
                // Save options
                save_stats: true,
                save_scenario_figs: true,
                save_every: 1,
                // Scenario options
                normalize: true,  // Normalize utility functions (recommended for tournaments)
                ignore_discount: false,  // Ignore discounting in utility functions
                ignore_reserved: false,  // Ignore reserved values in utility functions
                // Storage/memory optimization options
                storage_optimization: 'balanced',  // 'speed'|'balanced'|'space'|'max' - controls disk space usage
                memory_optimization: 'balanced',   // 'speed'|'balanced'|'space' - controls RAM usage
                storage_format: null,              // null|'csv'|'gzip'|'parquet' - format for large files
            },
            tournamentTab: 'scenarios',
            tournamentScenarioSearch: '',
            tournamentScenarioSourceFilter: '',
            tournamentScenarioFilters: {
                minOutcomes: null,
                maxOutcomes: null,
                minRationalFraction: null,
                maxRationalFraction: null,
                minOpposition: null,
                maxOpposition: null,
                showAdvanced: false,
            },
            tournamentCompetitorSearch: '',
            tournamentCompetitorSourceFilter: '',
            tournamentCompetitorTagFilter: '',  // Tag filter for tournament competitors
            tournamentOpponentSearch: '',
            tournamentOpponentSourceFilter: '',
            
            // Tournament presets
            tournamentPresets: [],
            selectedTournamentPreset: '',
            tournamentPresetName: '',
            
            // Virtual negotiators
            virtualNegotiators: [],
            virtualNegotiatorsLoading: false,
            
            // Competitor configuration modal state
            showCompetitorConfig: false,
            competitorConfigTypeName: null,  // Type being configured
            competitorConfigParams: [],       // Parameters from API
            competitorConfigValues: {},       // Current values being edited
            competitorConfigLoading: false,
            competitorConfigSaveAsVirtual: false,  // Whether to save as virtual negotiator
            competitorConfigVirtualName: '',       // Name for new virtual negotiator
            
            // Tabs
            negotiationTab: 'scenario',
            settingsTab: 'general',
            paramSubTab: 'deadline',
            negotiatorSubTab: 'preset',
            
            // Parameter group collapse states
            showAdvancedDeadline: false,
            showCommonParams: false,
            showSAOResponse: true,
            showSAOOffers: false,
            showSAOSemantics: false,
            showSAOAdvanced: false,
            showTAUBasic: true,
            showTAUAdvanced: false,
            showGBBasic: true,
            showGBOffers: false,
            
            // Data
            sources: [],
            scenarios: [],
            scenarioSearch: '',
            negotiatorTypes: [],
            negotiatorSources: [],
            negotiatorSearch: '',
            negotiatorSourceFilter: '',
            negotiatorGroupFilter: '',
            negotiatorTagFilter: '',  // Filter by tag
            allNegotiatorTags: [],    // All available tags from negotiators
            selectedNegotiatorSlot: 0,
            
            // Advanced scenario filters (shared between dialogs)
            scenarioFilters: {
                minOutcomes: null,
                maxOutcomes: null,
                minRationalFraction: null,
                maxRationalFraction: null,
                minOpposition: null,
                maxOpposition: null,
                showAdvanced: false,
            },
            explorerFilters: {
                minOutcomes: null,
                maxOutcomes: null,
                minRationalFraction: null,
                maxRationalFraction: null,
                minOpposition: null,
                maxOpposition: null,
                showAdvanced: false,
            },
            
            // Bulk stats calculation state
            bulkStatsProgress: null,  // { completed, total, current_path, errors }
            bulkStatsRunning: false,
            
            // Mechanism data (loaded from API)
            mechanisms: [],
            selectedMechanism: null,
            
            // Virtual mechanisms
            virtualMechanisms: [],
            virtualMechanismsLoading: false,
            
            // Save as Virtual Mechanism modal state
            showSaveVirtualMechanism: false,
            saveVirtualMechanismName: '',
            saveVirtualMechanismDescription: '',
            saveVirtualMechanismTags: '',
            
            // BOA (Build Custom) negotiator config
            boaComponents: {
                acceptance: [],
                offering: [],
                model: []
            },
            boaConfig: {
                acceptance_policy: '',
                offering_policy: '',
                opponent_model: ''
            },
            
            // MAP (Modular Agent Policy) negotiator config - more flexible than BOA
            mapConfig: {
                acceptance_policy: '',
                offering_policy: '',
                models: [],  // Multiple models (unlike BOA which has just one)
                extra_components: [],  // Additional arbitrary components
                acceptance_first: true  // Whether acceptance is evaluated before offering
            },
            
            // Scenario Explorer state
            explorerScenarios: [],
            explorerSearch: '',
            explorerSourceFilter: '',
            selectedScenario: null,
            explorerLoading: false,
            scenarioStats: null,  // Stats for the selected scenario
            scenarioStatsLoading: false,
            scenarioStatsError: null,
            
            // Negotiator Explorer state
            explorerNegotiators: [],
            filteredExplorerNegotiators: [],
            negotiatorExplorerSearch: '',
            negotiatorExplorerSourceFilter: '',
            negotiatorExplorerGroupFilter: '',
            selectedExplorerNegotiator: null,
            negotiatorExplorerLoading: false,
            negotiatorExplorerParams: [],
            negotiatorExplorerParamsLoading: false,
            virtualNegotiatorParams: {},
            virtualNegotiatorName: '',
            creatingVirtualNegotiator: false,
            baseTypeVirtualNegotiators: [],
            baseTypeVirtualNegotiatorsLoading: false,
            editingVirtualNegotiator: null,
            
            // Running/completed negotiations
            runningNegotiations: [],
            completedNegotiations: [],
            currentNegotiation: null,
            
            // New negotiation form
            newNeg: {
                source: '',
                scenario: null,
                negotiators: [
                    { type_name: 'negmas.sao.AspirationNegotiator', name: 'Aspiration1', source: 'native', params: {} },
                    { type_name: 'negmas.sao.BoulwareTBNegotiator', name: 'Boulware2', source: 'native', params: {} }
                ],
                // Scenario loading options
                ignore_discount: false,
                ignore_reserved: false,
                normalize: false,  // Normalize utility functions to [0, 1]
                // Mechanism type (class name)
                mechanism_type: 'SAOMechanism',
                // Dynamic mechanism params (populated from API)
                mechanism_params: {},
                // Information sharing
                share_ufuns: false,
                // Display params
                mode: 'realtime',
                step_delay: 100,
                show_plot: true,
                show_offers: true,
                auto_save: true,  // Default from settings.saveNegotiations
                // Panel settings
                panels: {
                    adjustable: true,
                    utilityView: { xAxis: 0, yAxis: 1 },
                    timeline: { xAxis: 'relative_time' }
                }
            },
            
            // Settings
            settings: {
                darkMode: localStorage.getItem('darkMode') === 'true',
                colorBlindMode: localStorage.getItem('colorBlindMode') === 'true',
                saveNegotiations: localStorage.getItem('saveNegotiations') !== 'false',  // Default true
                cacheScenarioStats: true,  // Default true - cache scenario stats for faster loading
                defaultSteps: 100,
                defaultDelay: 100,
                autoStartGenius: true,
                scenarioPaths: '',
                negotiatorPaths: '',
                // Performance settings
                maxOutcomesRun: null,  // No limit by default
                maxOutcomesStats: 1000000,  // 1M outcomes
                maxOutcomesInfo: 10000000,  // 10M outcomes
            },
            
            // Genius bridge
            geniusBridge: {
                installed: false,
                running: false,
                loading: false,
                port: 25337
            },
            
            // Negotiator source settings
            sourceSettings: {
                disabled_sources: [],
                custom_sources: []
            },
            sourceSettingsList: [],
            refreshingNegotiators: false,
            
            // Export/Import state
            exportingSettings: false,
            importingSettings: false,
            importStatus: '',
            
            // Preset management
            recentSessions: [],
            sessionPresets: [],
            showSaveSessionModal: false,
            savePresetName: '',
            
            // Shared scenario filter function
            applyScenarioFilters(scenarios, filters, source = null, search = '') {
                let results = scenarios;
                
                // Filter by source if selected
                if (source) {
                    results = results.filter(s => s.source === source);
                }
                
                // Filter by search term
                if (search) {
                    const searchLower = search.toLowerCase();
                    results = results.filter(s => 
                        s.name.toLowerCase().includes(searchLower) ||
                        s.source.toLowerCase().includes(searchLower)
                    );
                }
                
                // Filter by n_outcomes range
                if (filters.minOutcomes !== null && filters.minOutcomes !== '') {
                    const min = parseInt(filters.minOutcomes, 10);
                    if (!isNaN(min)) {
                        results = results.filter(s => s.n_outcomes !== null && s.n_outcomes >= min);
                    }
                }
                if (filters.maxOutcomes !== null && filters.maxOutcomes !== '') {
                    const max = parseInt(filters.maxOutcomes, 10);
                    if (!isNaN(max)) {
                        results = results.filter(s => s.n_outcomes !== null && s.n_outcomes <= max);
                    }
                }
                
                // Filter by rational_fraction range
                if (filters.minRationalFraction !== null && filters.minRationalFraction !== '') {
                    const min = parseFloat(filters.minRationalFraction);
                    if (!isNaN(min)) {
                        results = results.filter(s => s.rational_fraction !== null && s.rational_fraction >= min);
                    }
                }
                if (filters.maxRationalFraction !== null && filters.maxRationalFraction !== '') {
                    const max = parseFloat(filters.maxRationalFraction);
                    if (!isNaN(max)) {
                        results = results.filter(s => s.rational_fraction !== null && s.rational_fraction <= max);
                    }
                }
                
                // Filter by opposition range
                if (filters.minOpposition !== null && filters.minOpposition !== '') {
                    const min = parseFloat(filters.minOpposition);
                    if (!isNaN(min)) {
                        results = results.filter(s => s.opposition !== null && s.opposition >= min);
                    }
                }
                if (filters.maxOpposition !== null && filters.maxOpposition !== '') {
                    const max = parseFloat(filters.maxOpposition);
                    if (!isNaN(max)) {
                        results = results.filter(s => s.opposition !== null && s.opposition <= max);
                    }
                }
                
                return results;
            },
            
            // Computed
            get filteredScenarios() {
                return this.applyScenarioFilters(
                    this.scenarios,
                    this.scenarioFilters,
                    this.newNeg.source,
                    this.scenarioSearch
                );
            },
            
            get filteredNegotiators() {
                let results = this.negotiatorTypes;
                
                // Filter by source if selected
                if (this.negotiatorSourceFilter) {
                    results = results.filter(n => n.source === this.negotiatorSourceFilter);
                }
                
                // Filter by group if selected (for genius)
                if (this.negotiatorGroupFilter) {
                    results = results.filter(n => n.group === this.negotiatorGroupFilter);
                }
                
                // Filter by tag if selected
                if (this.negotiatorTagFilter) {
                    const tag = this.negotiatorTagFilter.toLowerCase();
                    results = results.filter(n => 
                        n.tags && n.tags.some(t => t.toLowerCase() === tag)
                    );
                }
                
                // Filter by search term
                if (this.negotiatorSearch) {
                    const search = this.negotiatorSearch.toLowerCase();
                    results = results.filter(n => 
                        n.name.toLowerCase().includes(search) ||
                        n.type_name.toLowerCase().includes(search) ||
                        (n.description && n.description.toLowerCase().includes(search))
                    );
                }
                
                return results;
            },
            
            get filteredExplorerScenarios() {
                return this.applyScenarioFilters(
                    this.explorerScenarios,
                    this.explorerFilters,
                    this.explorerSourceFilter,
                    this.explorerSearch
                );
            },
            
            get canProceed() {
                if (this.negotiationTab === 'scenario') {
                    return this.newNeg.scenario !== null;
                }
                if (this.negotiationTab === 'negotiators') {
                    return this.newNeg.negotiators.length >= (this.newNeg.scenario?.n_negotiators || 2);
                }
                return true;
            },
            
            get canStart() {
                if (this.newNeg.scenario === null) return false;
                if (this.newNeg.negotiators.length < (this.newNeg.scenario?.n_negotiators || 2)) return false;
                // Check deadline requirement - most mechanisms need some form of limit
                if (!this.hasDeadline()) return false;
                return true;
            },
            
            // Helper methods
            hasDeadline() {
                const params = this.newNeg.mechanism_params || {};
                return (params.n_steps && params.n_steps > 0) ||
                       (params.time_limit && params.time_limit > 0) ||
                       (params.pend && params.pend > 0) ||
                       (params.pend_per_second && params.pend_per_second > 0) ||
                       (params.hidden_time_limit && params.hidden_time_limit > 0 && params.hidden_time_limit !== 'inf');
            },
            
            // Tab validation helpers - returns true if tab is valid (no errors)
            isScenarioTabValid() {
                return this.newNeg.scenario !== null;
            },
            
            isNegotiatorsTabValid() {
                const required = this.newNeg.scenario?.n_negotiators || 2;
                return this.newNeg.negotiators.length >= required;
            },
            
            isParametersTabValid() {
                // Parameters tab requires a deadline for SAO mechanism
                if (this.newNeg.mechanism_type === 'SAOMechanism') {
                    return this.hasDeadline();
                }
                return true;
            },
            
            // Check if a tab has an error that prevents starting
            tabHasError(tabName) {
                switch(tabName) {
                    case 'scenario':
                        return !this.isScenarioTabValid();
                    case 'negotiators':
                        return this.isScenarioTabValid() && !this.isNegotiatorsTabValid();
                    case 'parameters':
                        return this.isScenarioTabValid() && this.isNegotiatorsTabValid() && !this.isParametersTabValid();
                    default:
                        return false;
                }
            },
            
            // Get error message for a tab
            getTabErrorMessage(tabName) {
                switch(tabName) {
                    case 'scenario':
                        if (!this.newNeg.scenario) return 'Select a scenario';
                        break;
                    case 'negotiators':
                        const required = this.newNeg.scenario?.n_negotiators || 2;
                        const current = this.newNeg.negotiators.length;
                        if (current < required) return `Need ${required} negotiators (have ${current})`;
                        break;
                    case 'parameters':
                        if (!this.hasDeadline()) return 'Set a deadline (steps or time limit)';
                        break;
                }
                return null;
            },
            
            getDeadlineSummary() {
                const params = this.newNeg.mechanism_params || {};
                const parts = [];
                if (params.n_steps && params.n_steps > 0) {
                    parts.push(params.n_steps + ' steps');
                }
                if (params.time_limit && params.time_limit > 0) {
                    parts.push(params.time_limit + 's time');
                }
                if (params.pend && params.pend > 0) {
                    parts.push('pend=' + params.pend);
                }
                if (params.pend_per_second && params.pend_per_second > 0) {
                    parts.push('pend/s=' + params.pend_per_second);
                }
                if (params.hidden_time_limit && params.hidden_time_limit > 0 && params.hidden_time_limit !== 'inf') {
                    parts.push('hidden=' + params.hidden_time_limit + 's');
                }
                return parts.length > 0 ? parts.join(', ') : 'None';
            },
            
            getMechanismDescription(type) {
                const descriptions = {
                    sao: 'Sequential offers with acceptance/rejection. Most common protocol.',
                    tau: 'Parallel offers in multiple threads. Can run without deadline.',
                    gb: 'General game-based mechanism with configurable evaluators.'
                };
                return descriptions[type] || '';
            },
            
            // Format configured parameters for display
            formatConfiguredParams(params) {
                if (!params || Object.keys(params).length === 0) return '';
                return Object.entries(params)
                    .map(([key, value]) => {
                        let displayValue;
                        const valueType = typeof value;
                        if (value === null || value === undefined) {
                            displayValue = 'null';
                        } else if (valueType === 'boolean') {
                            displayValue = value ? 'true' : 'false';
                        } else if (valueType === 'number') {
                            displayValue = Number.isInteger(value) ? value.toString() : value.toFixed(3).replace(/\.?0+$/, '');
                        } else if (valueType === 'string') {
                            displayValue = `"${value}"`;
                        } else if (Array.isArray(value)) {
                            displayValue = `[${value.length}]`;
                        } else if (valueType === 'object') {
                            displayValue = '{...}';
                        } else {
                            displayValue = String(value);
                        }
                        return `${key}=${displayValue}`;
                    })
                    .join(', ');
            },
            
            // Toast notification
            showToast(message, type = 'success') {
                this.toastMessage = message;
                this.toastType = type;
                this.toastVisible = true;
                setTimeout(() => {
                    this.toastVisible = false;
                }, 3000);
            },
            
            // Init
            async init() {
                // Watch sidebar state
                this.$watch('sidebarCollapsed', (val) => {
                    localStorage.setItem('sidebarCollapsed', val);
                });
                
                // Load settings from backend first
                await this.loadSettings();
                
                // Apply dark mode to body (html already has it from inline script)
                if (this.settings.darkMode) {
                    document.body.classList.add('dark-mode');
                }
                await this.loadSources();
                await this.loadNegotiatorSources();
                await this.loadNegotiatorTypes();
                await this.loadMechanisms();
                await this.loadVirtualNegotiators();
                await this.loadVirtualMechanisms();
                // Pre-load all scenarios so search is instant
                await this.loadAllScenarios();
                // Load tournament presets
                await this.loadTournamentPresets();
                this.initSortable();
                
                // Check Genius Bridge status
                await this.checkGeniusBridgeStatus();
                // Periodically check status (every 60 seconds)
                setInterval(() => this.checkGeniusBridgeStatus(), 60000);
            },
            
            initSortable() {
                this.$watch('showNewNegotiation', (show) => {
                    if (show) {
                        this.$nextTick(() => {
                            const list = this.$refs.negotiatorList;
                            if (list && !list._sortable) {
                                list._sortable = new Sortable(list, {
                                    handle: '.drag-handle',
                                    animation: 150,
                                    onEnd: (evt) => {
                                        const item = this.newNeg.negotiators.splice(evt.oldIndex, 1)[0];
                                        this.newNeg.negotiators.splice(evt.newIndex, 0, item);
                                    }
                                });
                            }
                        });
                    }
                });
            },
            
            // API calls
            async loadSources() {
                try {
                    const res = await fetch('/api/scenarios/sources');
                    const data = await res.json();
                    this.sources = data.sources;
                } catch (e) {
                    console.error('Failed to load sources:', e);
                }
            },
            
            async loadAllScenarios() {
                if (this.scenarios.length > 0) return; // Already loaded
                this.scenariosLoading = true;
                try {
                    const res = await fetch('/api/scenarios');
                    const data = await res.json();
                    this.scenarios = data.scenarios;
                } catch (e) {
                    console.error('Failed to load scenarios:', e);
                } finally {
                    this.scenariosLoading = false;
                }
            },
            
            async searchScenarios() {
                // Load all scenarios on first search
                await this.loadAllScenarios();
            },
            
            async filterBySource() {
                // Load all scenarios when filtering
                await this.loadAllScenarios();
            },
            
            // Scenario Explorer methods
            async loadScenariosForExplorer() {
                if (this.explorerScenarios.length > 0) return; // Already loaded
                this.explorerLoading = true;
                try {
                    const res = await fetch('/api/scenarios');
                    const data = await res.json();
                    this.explorerScenarios = data.scenarios;
                } catch (e) {
                    console.error('Failed to load scenarios for explorer:', e);
                } finally {
                    this.explorerLoading = false;
                }
            },
            
            selectScenarioForExplorer(scenario) {
                this.selectedScenario = scenario;
                // Clear previous stats
                this.scenarioStats = null;
                this.scenarioStatsError = null;
                // Auto-load stats if they're cached (fast operation)
                if (scenario.has_stats) {
                    this.loadScenarioStats(scenario.path);
                }
            },
            
            async loadScenarioStats(path) {
                this.scenarioStatsLoading = true;
                this.scenarioStatsError = null;
                try {
                    const res = await fetch(`/api/scenarios/${encodeURIComponent(path)}/stats`);
                    if (!res.ok) throw new Error('Failed to load stats');
                    this.scenarioStats = await res.json();
                } catch (e) {
                    console.error('Failed to load scenario stats:', e);
                    this.scenarioStatsError = 'Failed to load stats';
                } finally {
                    this.scenarioStatsLoading = false;
                }
            },
            
            async calculateScenarioStats(path, force = false) {
                this.scenarioStatsLoading = true;
                this.scenarioStatsError = null;
                try {
                    const res = await fetch(`/api/scenarios/${encodeURIComponent(path)}/stats/calculate?force=${force}`, {
                        method: 'POST'
                    });
                    if (!res.ok) throw new Error('Failed to calculate stats');
                    this.scenarioStats = await res.json();
                    // Update has_stats flag on the selected scenario
                    if (this.selectedScenario) {
                        this.selectedScenario.has_stats = true;
                    }
                } catch (e) {
                    console.error('Failed to calculate scenario stats:', e);
                    this.scenarioStatsError = 'Failed to calculate stats';
                } finally {
                    this.scenarioStatsLoading = false;
                }
            },
            
            async bulkCalculateStats(force = false) {
                // Get all scenarios that need stats calculation
                let paths;
                if (force) {
                    // Recalculate all scenarios
                    paths = this.explorerScenarios.map(s => s.path);
                } else {
                    // Only scenarios without stats
                    paths = this.explorerScenarios.filter(s => !s.has_stats).map(s => s.path);
                }
                
                if (paths.length === 0) {
                    console.log('No scenarios need stats calculation');
                    return;
                }
                
                this.bulkStatsRunning = true;
                this.bulkStatsProgress = { completed: 0, total: paths.length, current_path: '', errors: [] };
                
                try {
                    const res = await fetch('/api/scenarios/bulk-calculate-stats', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ paths, force })
                    });
                    
                    if (!res.ok) throw new Error('Failed to start bulk calculation');
                    
                    const reader = res.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    
                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;
                        
                        buffer += decoder.decode(value, { stream: true });
                        
                        // Parse SSE events from buffer
                        const lines = buffer.split('\n');
                        buffer = lines.pop() || ''; // Keep incomplete line in buffer
                        
                        for (const line of lines) {
                            if (line.startsWith('data:')) {
                                try {
                                    const data = JSON.parse(line.slice(5).trim());
                                    
                                    if (data.type === 'progress') {
                                        this.bulkStatsProgress = {
                                            completed: data.completed,
                                            total: data.total,
                                            current_path: data.current_path,
                                            errors: this.bulkStatsProgress?.errors || []
                                        };
                                        
                                        // Update the scenario's has_stats flag
                                        if (data.has_stats) {
                                            const scenario = this.explorerScenarios.find(s => s.path === data.current_path);
                                            if (scenario) {
                                                scenario.has_stats = true;
                                                if (data.rational_fraction !== undefined) {
                                                    scenario.rational_fraction = data.rational_fraction;
                                                }
                                            }
                                        }
                                        
                                        // Track errors
                                        if (data.error) {
                                            this.bulkStatsProgress.errors.push({ path: data.current_path, error: data.error });
                                        }
                                    } else if (data.type === 'complete') {
                                        this.bulkStatsProgress = {
                                            completed: data.completed,
                                            total: data.total,
                                            current_path: '',
                                            errors: data.errors || []
                                        };
                                    }
                                } catch (e) {
                                    // Ignore parse errors for incomplete JSON
                                }
                            }
                        }
                    }
                    
                    // Refresh scenarios list to get updated stats
                    await this.loadExplorerScenarios();
                    
                } catch (e) {
                    console.error('Failed to bulk calculate stats:', e);
                } finally {
                    this.bulkStatsRunning = false;
                }
            },
            
            useScenarioInNegotiation(scenario) {
                this.currentPage = 'negotiations';
                this.openNewNegotiation();
                this.newNeg.scenario = scenario;
                this.newNeg.source = scenario.source;
                this.negotiationTab = 'negotiators';
            },
            
            filterExplorerScenarios() {
                // Reactivity handles filtering via computed property
            },
            
            // ==========================================
            // Scenario Creator Functions
            // ==========================================
            
            openScenarioCreator() {
                this.showScenarioCreator = true;
                // Reset state
                this.scenarioCreator = {
                    name: '',
                    issues: [],
                    ufuns: [],
                    error: null,
                    creating: false,
                };
                // Add default 2 issues and 2 negotiators
                this.addIssue();
                this.addIssue();
                this.addUfun();
                this.addUfun();
            },
            
            addIssue() {
                this.scenarioCreator.issues.push({
                    name: '',
                    type: 'categorical',
                    values: [],
                    valuesText: '',
                    min_value: 0,
                    max_value: 10,
                });
                // Update ufun weights to match new issue count
                this.updateUfunWeights();
            },
            
            removeIssue(idx) {
                this.scenarioCreator.issues.splice(idx, 1);
                // Update ufun weights
                this.updateUfunWeights();
            },
            
            onIssueTypeChange(idx) {
                const issue = this.scenarioCreator.issues[idx];
                if (issue.type === 'categorical') {
                    issue.values = [];
                    issue.valuesText = '';
                } else {
                    issue.min_value = 0;
                    issue.max_value = 10;
                }
            },
            
            addUfun() {
                const n = this.scenarioCreator.ufuns.length;
                const issueCount = this.scenarioCreator.issues.length || 1;
                this.scenarioCreator.ufuns.push({
                    name: n === 0 ? 'Buyer' : n === 1 ? 'Seller' : `Negotiator ${n + 1}`,
                    type: 'linear_additive',
                    reserved_value: 0.0,
                    mode: 'weights',
                    weights: Array(issueCount).fill(1.0 / issueCount),
                    values: [],  // For detailed mode
                });
            },
            
            removeUfun(idx) {
                this.scenarioCreator.ufuns.splice(idx, 1);
            },
            
            updateUfunWeights() {
                const issueCount = this.scenarioCreator.issues.length || 1;
                for (const ufun of this.scenarioCreator.ufuns) {
                    // Resize weights array
                    while (ufun.weights.length < issueCount) {
                        ufun.weights.push(1.0 / issueCount);
                    }
                    while (ufun.weights.length > issueCount) {
                        ufun.weights.pop();
                    }
                }
            },
            
            setUfunWeight(ufunIdx, issueIdx, value) {
                if (!this.scenarioCreator.ufuns[ufunIdx].weights) {
                    this.scenarioCreator.ufuns[ufunIdx].weights = [];
                }
                this.scenarioCreator.ufuns[ufunIdx].weights[issueIdx] = parseFloat(value) || 0;
            },
            
            setUfunValueMapping(ufunIdx, issueIdx, value, utility) {
                const ufun = this.scenarioCreator.ufuns[ufunIdx];
                if (!ufun.valueMappings) {
                    ufun.valueMappings = {};
                }
                if (!ufun.valueMappings[issueIdx]) {
                    ufun.valueMappings[issueIdx] = {};
                }
                ufun.valueMappings[issueIdx][value] = parseFloat(utility) || 0;
            },
            
            async createScenario() {
                // Validation
                if (!this.scenarioCreator.name.trim()) {
                    this.scenarioCreator.error = 'Scenario name is required';
                    return;
                }
                if (this.scenarioCreator.issues.length === 0) {
                    this.scenarioCreator.error = 'At least one issue is required';
                    return;
                }
                if (this.scenarioCreator.ufuns.length < 2) {
                    this.scenarioCreator.error = 'At least two negotiators are required';
                    return;
                }
                
                // Validate issues
                for (let i = 0; i < this.scenarioCreator.issues.length; i++) {
                    const issue = this.scenarioCreator.issues[i];
                    if (!issue.name.trim()) {
                        this.scenarioCreator.error = `Issue ${i + 1} needs a name`;
                        return;
                    }
                    if (issue.type === 'categorical' && (!issue.values || issue.values.length === 0)) {
                        this.scenarioCreator.error = `Issue "${issue.name}" needs at least one value`;
                        return;
                    }
                }
                
                // Validate ufuns
                for (let i = 0; i < this.scenarioCreator.ufuns.length; i++) {
                    const ufun = this.scenarioCreator.ufuns[i];
                    if (!ufun.name.trim()) {
                        this.scenarioCreator.error = `Negotiator ${i + 1} needs a name`;
                        return;
                    }
                }
                
                this.scenarioCreator.error = null;
                this.scenarioCreator.creating = true;
                
                try {
                    // Build request payload
                    const payload = {
                        name: this.scenarioCreator.name.trim(),
                        issues: this.scenarioCreator.issues.map(i => ({
                            name: i.name.trim(),
                            type: i.type,
                            values: i.type === 'categorical' ? i.values : null,
                            min_value: i.type !== 'categorical' ? i.min_value : null,
                            max_value: i.type !== 'categorical' ? i.max_value : null,
                        })),
                        ufuns: this.scenarioCreator.ufuns.map(u => ({
                            name: u.name.trim(),
                            type: u.type,
                            reserved_value: u.reserved_value,
                            weights: u.weights,
                            values: u.mode === 'detailed' && u.valueMappings ? 
                                Object.entries(u.valueMappings).map(([issueIdx, mapping]) => ({
                                    issue_index: parseInt(issueIdx),
                                    type: 'table',
                                    mapping: mapping,
                                })) : null,
                        })),
                    };
                    
                    const res = await fetch('/api/scenarios/create', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload),
                    });
                    
                    const data = await res.json();
                    
                    if (!res.ok) {
                        throw new Error(data.detail || 'Failed to create scenario');
                    }
                    
                    // Success!
                    this.showToast(`Scenario "${this.scenarioCreator.name}" created successfully!`, 'success');
                    this.showScenarioCreator = false;
                    
                    // Refresh scenario lists
                    this.scenarios = [];  // Clear cache to force reload
                    this.explorerScenarios = [];
                    await this.loadAllScenarios();
                    
                    // If on scenarios page, reload explorer
                    if (this.currentPage === 'scenarios') {
                        await this.loadScenariosForExplorer();
                    }
                    
                } catch (e) {
                    console.error('Failed to create scenario:', e);
                    this.scenarioCreator.error = e.message || 'Failed to create scenario';
                } finally {
                    this.scenarioCreator.creating = false;
                }
            },
            
            // Negotiator Explorer functions
            async loadNegotiatorsForExplorer() {
                if (this.explorerNegotiators.length > 0) return; // Already loaded
                this.negotiatorExplorerLoading = true;
                try {
                    const res = await fetch('/api/negotiators');
                    const data = await res.json();
                    this.explorerNegotiators = data.negotiators;
                    this.filterExplorerNegotiators();
                } catch (e) {
                    console.error('Failed to load negotiators for explorer:', e);
                } finally {
                    this.negotiatorExplorerLoading = false;
                }
            },
            
            filterExplorerNegotiators() {
                let filtered = this.explorerNegotiators;
                
                // Filter by search
                if (this.negotiatorExplorerSearch) {
                    const search = this.negotiatorExplorerSearch.toLowerCase();
                    filtered = filtered.filter(n => 
                        n.name.toLowerCase().includes(search) ||
                        n.type_name.toLowerCase().includes(search) ||
                        (n.description && n.description.toLowerCase().includes(search)) ||
                        (n.tags && n.tags.some(t => t.toLowerCase().includes(search)))
                    );
                }
                
                // Filter by source
                if (this.negotiatorExplorerSourceFilter) {
                    filtered = filtered.filter(n => n.source === this.negotiatorExplorerSourceFilter);
                }
                
                // Filter by group
                if (this.negotiatorExplorerGroupFilter) {
                    filtered = filtered.filter(n => n.group === this.negotiatorExplorerGroupFilter);
                }
                
                this.filteredExplorerNegotiators = filtered;
            },
            
            async selectNegotiatorForExplorer(negotiator) {
                this.selectedExplorerNegotiator = negotiator;
                this.virtualNegotiatorParams = {};
                this.virtualNegotiatorName = negotiator.name;
                
                // Load parameters and virtual negotiators in parallel
                await Promise.all([
                    this.loadNegotiatorExplorerParams(negotiator.type_name),
                    this.loadBaseTypeVirtualNegotiators(negotiator.type_name)
                ]);
            },
            
            async loadBaseTypeVirtualNegotiators(typeName) {
                this.baseTypeVirtualNegotiatorsLoading = true;
                this.baseTypeVirtualNegotiators = [];
                try {
                    const res = await fetch(`/api/negotiators/virtual/by-base/${encodeURIComponent(typeName)}?include_disabled=true`);
                    if (!res.ok) throw new Error('Failed to load virtual negotiators');
                    const data = await res.json();
                    this.baseTypeVirtualNegotiators = data.virtual_negotiators || [];
                } catch (e) {
                    console.error('Failed to load virtual negotiators:', e);
                } finally {
                    this.baseTypeVirtualNegotiatorsLoading = false;
                }
            },
            
            async loadNegotiatorExplorerParams(typeName) {
                this.negotiatorExplorerParamsLoading = true;
                this.negotiatorExplorerParams = [];
                try {
                    const res = await fetch(`/api/negotiators/${encodeURIComponent(typeName)}/parameters`);
                    if (!res.ok) throw new Error('Failed to load parameters');
                    const data = await res.json();
                    this.negotiatorExplorerParams = data.parameters || [];
                } catch (e) {
                    console.error('Failed to load negotiator parameters:', e);
                } finally {
                    this.negotiatorExplorerParamsLoading = false;
                }
            },
            
            async createVirtualNegotiator() {
                if (!this.selectedExplorerNegotiator) return;
                if (!this.virtualNegotiatorName.trim()) {
                    alert('Please enter a name for the virtual negotiator');
                    return;
                }
                
                this.creatingVirtualNegotiator = true;
                try {
                    // Convert empty string params to null/undefined
                    const cleanParams = {};
                    for (const [key, value] of Object.entries(this.virtualNegotiatorParams)) {
                        if (value !== '' && value !== null && value !== undefined) {
                            // Convert string booleans to actual booleans
                            if (value === 'true') cleanParams[key] = true;
                            else if (value === 'false') cleanParams[key] = false;
                            else cleanParams[key] = value;
                        }
                    }
                    
                    const res = await fetch('/api/negotiators/virtual', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            base_type_name: this.selectedExplorerNegotiator.type_name,
                            name: this.virtualNegotiatorName,
                            params: cleanParams
                        })
                    });
                    
                    if (!res.ok) {
                        const error = await res.json();
                        throw new Error(error.detail || 'Failed to create virtual negotiator');
                    }
                    
                    const data = await res.json();
                    alert(`Virtual negotiator "${this.virtualNegotiatorName}" created successfully!`);
                    
                    // Reset form
                    this.virtualNegotiatorParams = {};
                    this.virtualNegotiatorName = this.selectedExplorerNegotiator.name;
                    
                    // Refresh negotiator list and virtual negotiators list
                    this.explorerNegotiators = [];
                    await Promise.all([
                        this.loadNegotiatorsForExplorer(),
                        this.loadBaseTypeVirtualNegotiators(this.selectedExplorerNegotiator.type_name)
                    ]);
                    
                } catch (e) {
                    console.error('Failed to create virtual negotiator:', e);
                    alert('Failed to create virtual negotiator: ' + e.message);
                } finally {
                    this.creatingVirtualNegotiator = false;
                }
            },
            
            async toggleVirtualNegotiatorEnabled(vn) {
                const action = vn.enabled ? 'disable' : 'enable';
                try {
                    const res = await fetch(`/api/negotiators/virtual/${vn.id}/${action}`, {
                        method: 'POST'
                    });
                    if (!res.ok) {
                        const error = await res.json();
                        throw new Error(error.detail || `Failed to ${action} virtual negotiator`);
                    }
                    // Update local state
                    vn.enabled = !vn.enabled;
                } catch (e) {
                    console.error(`Failed to ${action} virtual negotiator:`, e);
                    alert(`Failed to ${action} virtual negotiator: ` + e.message);
                }
            },
            
            async editVirtualNegotiator(vn) {
                // For now, populate the form with the virtual negotiator's values for editing
                const newName = prompt('Enter new name for virtual negotiator:', vn.name);
                if (newName === null) return; // Cancelled
                if (!newName.trim()) {
                    alert('Name cannot be empty');
                    return;
                }
                
                const newDescription = prompt('Enter description (optional):', vn.description || '');
                if (newDescription === null) return; // Cancelled
                
                try {
                    const res = await fetch(`/api/negotiators/virtual/${vn.id}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            name: newName.trim(),
                            description: newDescription
                        })
                    });
                    
                    if (!res.ok) {
                        const error = await res.json();
                        throw new Error(error.detail || 'Failed to update virtual negotiator');
                    }
                    
                    // Refresh the list
                    await this.loadBaseTypeVirtualNegotiators(this.selectedExplorerNegotiator.type_name);
                    
                } catch (e) {
                    console.error('Failed to update virtual negotiator:', e);
                    alert('Failed to update virtual negotiator: ' + e.message);
                }
            },
            
            async deleteVirtualNegotiator(vn) {
                if (!confirm(`Are you sure you want to delete "${vn.name}"? This cannot be undone.`)) {
                    return;
                }
                
                try {
                    const res = await fetch(`/api/negotiators/virtual/${vn.id}`, {
                        method: 'DELETE'
                    });
                    
                    if (!res.ok) {
                        const error = await res.json();
                        throw new Error(error.detail || 'Failed to delete virtual negotiator');
                    }
                    
                    // Refresh both lists
                    await Promise.all([
                        this.loadNegotiatorsForExplorer(),
                        this.loadBaseTypeVirtualNegotiators(this.selectedExplorerNegotiator.type_name)
                    ]);
                    
                } catch (e) {
                    console.error('Failed to delete virtual negotiator:', e);
                    alert('Failed to delete virtual negotiator: ' + e.message);
                }
            },
            
            async loadNegotiatorTypes() {
                this.negotiatorsLoading = true;
                try {
                    const res = await fetch('/api/negotiators');
                    const data = await res.json();
                    this.negotiatorTypes = data.negotiators;
                    
                    // Extract unique tags
                    const tagSet = new Set();
                    for (const neg of data.negotiators) {
                        if (neg.tags) {
                            for (const tag of neg.tags) {
                                tagSet.add(tag);
                            }
                        }
                    }
                    this.allNegotiatorTags = Array.from(tagSet).sort();
                } catch (e) {
                    console.error('Failed to load negotiator types:', e);
                } finally {
                    this.negotiatorsLoading = false;
                }
            },
            
            async loadNegotiatorSources() {
                try {
                    const res = await fetch('/api/negotiators/sources');
                    const data = await res.json();
                    this.negotiatorSources = data.sources;
                } catch (e) {
                    console.error('Failed to load negotiator sources:', e);
                }
            },
            
            async loadMechanisms() {
                try {
                    const res = await fetch('/api/mechanisms');
                    const data = await res.json();
                    this.mechanisms = data.mechanisms;
                    // Select SAOMechanism by default
                    this.selectMechanism('SAOMechanism');
                } catch (e) {
                    console.error('Failed to load mechanisms:', e);
                }
            },
            
            selectMechanism(className) {
                // Check if it's a virtual mechanism
                if (this.isVirtualMechanism(className)) {
                    const vm = this.getVirtualMechanism(className);
                    if (vm) {
                        // Find the base mechanism info
                        const baseClassName = this.getBaseTypeFromVirtualMechanism(className);
                        this.selectedMechanism = this.mechanisms.find(m => m.class_name === baseClassName);
                        this.newNeg.mechanism_type = className;
                        // Initialize with virtual mechanism's saved params
                        this.initMechanismParams();
                        // Override with saved params from virtual mechanism
                        for (const [key, value] of Object.entries(vm.params || {})) {
                            this.newNeg.mechanism_params[key] = value;
                        }
                    }
                } else {
                    this.selectedMechanism = this.mechanisms.find(m => m.class_name === className);
                    if (this.selectedMechanism) {
                        this.newNeg.mechanism_type = className;
                        // Initialize mechanism params with defaults
                        this.initMechanismParams();
                    }
                }
            },
            
            initMechanismParams() {
                if (!this.selectedMechanism) return;
                
                // Reset mechanism_params to defaults
                this.newNeg.mechanism_params = {};
                
                for (const group of this.selectedMechanism.param_groups) {
                    for (const param of group.params) {
                        // Set default value
                        let defaultVal = param.default;
                        if (defaultVal === 'inf') defaultVal = null;
                        if (defaultVal === '-inf') defaultVal = null;
                        this.newNeg.mechanism_params[param.name] = defaultVal;
                    }
                }
            },
            
            getMechanismParamValue(paramName) {
                return this.newNeg.mechanism_params?.[paramName];
            },
            
            setMechanismParamValue(paramName, value) {
                if (!this.newNeg.mechanism_params) {
                    this.newNeg.mechanism_params = {};
                }
                this.newNeg.mechanism_params[paramName] = value;
            },
            
            async loadSourceSettings() {
                try {
                    // Load source settings from backend
                    const res = await fetch('/api/settings/negotiator_sources');
                    if (res.ok) {
                        const data = await res.json();
                        this.sourceSettings = data;
                    }
                    
                    // Build the list with availability info from negotiatorSources
                    this.sourceSettingsList = this.negotiatorSources.map(source => {
                        const count = this.negotiatorTypes.filter(n => n.source === source.id).length;
                        return {
                            ...source,
                            count: count,
                            available: source.available !== false,
                            unavailable_reason: source.unavailable_reason
                        };
                    });
                } catch (e) {
                    console.error('Failed to load source settings:', e);
                }
            },
            
            // Genius Bridge methods
            async checkGeniusBridgeStatus() {
                try {
                    const res = await fetch('/api/genius/status');
                    if (res.ok) {
                        const data = await res.json();
                        this.geniusBridge.installed = data.installed;
                        this.geniusBridge.running = data.running;
                        this.geniusBridge.port = data.port;
                    }
                } catch (e) {
                    console.error('Failed to check Genius Bridge status:', e);
                }
            },
            
            async startGeniusBridge() {
                if (this.geniusBridge.loading) return;
                this.geniusBridge.loading = true;
                try {
                    const res = await fetch('/api/genius/start', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ port: this.geniusBridge.port })
                    });
                    if (res.ok) {
                        const data = await res.json();
                        if (data.success) {
                            this.geniusBridge.running = true;
                            this.geniusBridge.port = data.port;
                        } else {
                            console.error('Failed to start Genius Bridge:', data.message);
                            alert('Failed to start Genius Bridge: ' + data.message);
                        }
                    }
                } catch (e) {
                    console.error('Failed to start Genius Bridge:', e);
                } finally {
                    this.geniusBridge.loading = false;
                }
            },
            
            async stopGeniusBridge() {
                if (this.geniusBridge.loading) return;
                this.geniusBridge.loading = true;
                try {
                    const res = await fetch('/api/genius/stop?port=' + this.geniusBridge.port, {
                        method: 'POST'
                    });
                    if (res.ok) {
                        const data = await res.json();
                        if (data.success) {
                            this.geniusBridge.running = false;
                        }
                    }
                } catch (e) {
                    console.error('Failed to stop Genius Bridge:', e);
                } finally {
                    this.geniusBridge.loading = false;
                }
            },
            
            async toggleGeniusBridge() {
                if (this.geniusBridge.running) {
                    await this.stopGeniusBridge();
                } else {
                    await this.startGeniusBridge();
                }
            },
            
            async ensureGeniusBridgeRunning() {
                if (!this.geniusBridge.running) {
                    await this.startGeniusBridge();
                }
                return this.geniusBridge.running;
            },
            
            toggleSource(sourceId) {
                const idx = this.sourceSettings.disabled_sources.indexOf(sourceId);
                if (idx >= 0) {
                    this.sourceSettings.disabled_sources.splice(idx, 1);
                } else {
                    this.sourceSettings.disabled_sources.push(sourceId);
                }
            },
            
            async refreshNegotiators() {
                this.refreshingNegotiators = true;
                try {
                    await fetch('/api/negotiators/refresh', { method: 'POST' });
                    await this.loadNegotiatorTypes();
                    await this.loadNegotiatorSources();
                    await this.loadSourceSettings();
                } catch (e) {
                    console.error('Failed to refresh negotiators:', e);
                } finally {
                    this.refreshingNegotiators = false;
                }
            },
            
            async clearParameterCache() {
                try {
                    const res = await fetch('/api/negotiators/cache/clear', { method: 'POST' });
                    const data = await res.json();
                    alert(data.message || 'Parameter cache cleared');
                } catch (e) {
                    console.error('Failed to clear parameter cache:', e);
                    alert('Failed to clear parameter cache');
                }
            },
            
            async searchNegotiators() {
                // Negotiators already loaded at init, just triggers reactivity
            },
            
            async filterNegotiators() {
                // Reset group filter if source changed
                if (this.negotiatorSourceFilter !== 'genius') {
                    this.negotiatorGroupFilter = '';
                }
            },
            
            // Modal actions
            openNewNegotiation() {
                this.showNewNegotiation = true;
                this.negotiationTab = 'scenario';
                this.paramSubTab = 'deadline';
                this.scenarioSearch = '';
                this.negotiatorSearch = '';
                this.negotiatorSourceFilter = '';
                this.negotiatorGroupFilter = '';
                this.negotiatorTagFilter = '';
                this.showAdvancedDeadline = false;
                this.showSAOResponse = true;
                this.showSAOOffers = false;
                this.showSAOSemantics = false;
                this.showInfoSharing = true;
                this.newNeg = {
                    source: '',
                    scenario: null,
                    negotiators: [
                        { type_name: 'negmas.sao.AspirationNegotiator', name: 'Aspiration1', source: 'native', params: {} },
                        { type_name: 'negmas.sao.BoulwareTBNegotiator', name: 'Boulware2', source: 'native', params: {} }
                    ],
                    mechanism_type: 'SAOMechanism',
                    mechanism_params: {},
                    share_ufuns: false,
                    mode: 'realtime',
                    step_delay: this.settings.defaultDelay,
                    show_plot: true,
                    show_offers: true,
                    auto_save: this.settings.saveNegotiations,
                    auto_start: true,
                    panels: {
                        adjustable: true,
                        utilityView: {
                            xAxis: 0,
                            yAxis: 1
                        },
                        timeline: {
                            xAxis: 'step'
                        }
                    }
                };
                // Initialize mechanism params with defaults
                this.selectMechanism('SAOMechanism');
            },
            
            selectScenario(scenario) {
                this.newNeg.scenario = scenario;
                // Adjust negotiator count if needed
                while (this.newNeg.negotiators.length < scenario.n_negotiators) {
                    this.addNegotiator();
                }
                while (this.newNeg.negotiators.length > scenario.n_negotiators) {
                    this.newNeg.negotiators.pop();
                }
            },
            
            nextNegotiationTab() {
                if (this.negotiationTab === 'scenario') this.negotiationTab = 'negotiators';
                else if (this.negotiationTab === 'negotiators') this.negotiationTab = 'parameters';
                else if (this.negotiationTab === 'parameters') this.negotiationTab = 'panels';
                else if (this.negotiationTab === 'panels') this.negotiationTab = 'display';
            },
            
            prevNegotiationTab() {
                if (this.negotiationTab === 'display') this.negotiationTab = 'panels';
                else if (this.negotiationTab === 'panels') this.negotiationTab = 'parameters';
                else if (this.negotiationTab === 'parameters') this.negotiationTab = 'negotiators';
                else if (this.negotiationTab === 'negotiators') this.negotiationTab = 'scenario';
            },
            
            // Negotiator management
            addNegotiator() {
                const idx = this.newNeg.negotiators.length;
                this.newNeg.negotiators.push({
                    type_name: 'negmas.sao.AspirationNegotiator',
                    name: `Aspiration${idx + 1}`,
                    source: 'native',
                    params: {}
                });
            },
            
            removeNegotiator(index) {
                if (this.newNeg.negotiators.length > 2) {
                    this.newNeg.negotiators.splice(index, 1);
                }
            },
            
            selectNegotiatorForSlot(negInfo) {
                // Use the currently selected slot
                const slotIndex = this.selectedNegotiatorSlot;
                const existingName = this.newNeg.negotiators[slotIndex]?.name;
                
                // Generate default name from type name + index if user hasn't set a custom name
                // Check if existing name is a generic "AgentN" or empty
                const isGenericName = !existingName || /^Agent\d+$/.test(existingName);
                const shortTypeName = negInfo.name || negInfo.type_name.split('.').pop();
                const defaultName = isGenericName ? `${shortTypeName}${slotIndex + 1}` : existingName;
                
                const newNeg = {
                    type_name: negInfo.type_name,
                    name: defaultName,
                    source: negInfo.source,
                    requires_bridge: negInfo.requires_bridge,
                    params: {}  // Initialize empty params
                };
                
                if (slotIndex < this.newNeg.negotiators.length) {
                    // Use splice for proper Alpine.js reactivity
                    this.newNeg.negotiators.splice(slotIndex, 1, newNeg);
                } else {
                    this.newNeg.negotiators.push(newNeg);
                }
                
                // Auto-start Genius Bridge if needed
                if (negInfo.requires_bridge && this.settings.autoStartGenius && !this.geniusBridge.running) {
                    this.startGeniusBridge();
                }
                
                // Auto-advance to next slot if there's room
                const requiredCount = this.newNeg.scenario?.n_negotiators || 2;
                if (slotIndex + 1 < requiredCount && slotIndex + 1 < this.newNeg.negotiators.length) {
                    this.selectedNegotiatorSlot = slotIndex + 1;
                }
            },
            
            async openNegotiatorConfig(index) {
                this.configNegotiatorIndex = index;
                this.configNegotiatorLoading = true;
                this.configNegotiatorParams = [];
                this.configNegotiatorValues = {};
                this.showNegotiatorConfig = true;
                
                const negotiator = this.newNeg.negotiators[index];
                if (!negotiator) return;
                
                try {
                    const res = await fetch(`/api/negotiators/${encodeURIComponent(negotiator.type_name)}/parameters`);
                    const data = await res.json();
                    
                    // Filter out 'name' parameter since we handle it separately
                    this.configNegotiatorParams = (data.parameters || []).filter(p => p.name !== 'name');
                    
                    // Initialize values from existing params or defaults
                    const existingParams = negotiator.params || {};
                    this.configNegotiatorValues = {};
                    
                    for (const param of this.configNegotiatorParams) {
                        if (param.name in existingParams) {
                            this.configNegotiatorValues[param.name] = existingParams[param.name];
                        }
                        // Otherwise leave undefined to use default
                    }
                } catch (e) {
                    console.error('Failed to load negotiator parameters:', e);
                } finally {
                    this.configNegotiatorLoading = false;
                }
            },
            
            applyNegotiatorConfig() {
                if (this.configNegotiatorIndex === null) return;
                
                // Build params object with only non-default values
                const params = {};
                for (const param of this.configNegotiatorParams) {
                    const value = this.configNegotiatorValues[param.name];
                    // Only include if value was explicitly set and differs from default
                    if (value !== undefined && value !== null && value !== param.default) {
                        params[param.name] = value;
                    }
                }
                
                // Update negotiator params
                this.newNeg.negotiators[this.configNegotiatorIndex].params = params;
                this.showNegotiatorConfig = false;
            },
            
            resetNegotiatorConfig() {
                // Reset all values to undefined (will use defaults)
                this.configNegotiatorValues = {};
            },
            
            getNegotiatorDisplayName(typeName) {
                // Handle BOA negotiators (type_name format: "BOA:AcceptPolicy/OfferPolicy" or "BOA:AcceptPolicy/OfferPolicy/Model")
                if (typeName && typeName.startsWith('BOA:')) {
                    const parts = typeName.substring(4).split('/');
                    if (parts.length >= 2) {
                        const acc = parts[0].replace(/Policy$|^G|^AC/, '');
                        const off = parts[1].replace(/Policy$|Offering$|^G/, '');
                        return `${acc}+${off}`;
                    }
                    return 'Custom BOA';
                }
                // Handle MAP negotiators (type_name format: "MAP:AcceptPolicy/OfferPolicy")
                if (typeName && typeName.startsWith('MAP:')) {
                    const parts = typeName.substring(4).split('/');
                    if (parts.length >= 2) {
                        const acc = parts[0].replace(/Policy$|^G|^AC/, '');
                        const off = parts[1].replace(/Policy$|Offering$|^G/, '');
                        return `MAP:${acc}+${off}`;
                    }
                    return 'Custom MAP';
                }
                const neg = this.negotiatorTypes.find(n => n.type_name === typeName);
                return neg?.name || typeName.split('.').pop();
            },
            
            getNegotiatorDescription(typeName) {
                const neg = this.negotiatorTypes.find(n => n.type_name === typeName);
                return neg?.description || '';
            },
            
            getSourceBadgeClass(source) {
                const classes = {
                    'native': 'badge-primary',
                    'genius': 'badge-warning',
                    'genius-reimplemented': 'badge-success',
                    'llm': 'badge-info',
                    'rl': 'badge-info',
                    'negolog': 'badge-secondary',
                    'boa': 'badge-info',
                    'map': 'badge-info'
                };
                return classes[source] || 'badge-neutral';
            },
            
            // BOA Component methods
            async loadBOAComponents() {
                if (this.boaComponents.acceptance.length > 0) return; // Already loaded
                try {
                    const res = await fetch('/api/negotiators/boa/components');
                    const data = await res.json();
                    this.boaComponents = data.components;
                } catch (e) {
                    console.error('Failed to load BOA components:', e);
                }
            },
            
            getBoaComponentDescription(type, name) {
                if (!name) return '';
                const components = this.boaComponents[type] || [];
                const c = components.find(c => c.name === name);
                return c?.description || '';
            },
            
            applyBOAToSlot() {
                if (!this.boaConfig.acceptance_policy || !this.boaConfig.offering_policy) return;
                
                const slotIndex = this.selectedNegotiatorSlot;
                const existingName = this.newNeg.negotiators[slotIndex]?.name;
                
                // Create a display name based on selected components
                const displayParts = [];
                displayParts.push(this.boaConfig.acceptance_policy.replace(/Policy$|^G/, ''));
                displayParts.push(this.boaConfig.offering_policy.replace(/Policy$|Offering$|^G/, ''));
                const displayName = displayParts.join('+');
                
                // Build type_name: BOA:Accept/Offer or BOA:Accept/Offer/Model
                let typeName = `BOA:${this.boaConfig.acceptance_policy}/${this.boaConfig.offering_policy}`;
                if (this.boaConfig.opponent_model) {
                    typeName += `/${this.boaConfig.opponent_model}`;
                }
                
                const boaNeg = {
                    type_name: typeName,
                    name: existingName || `Agent${slotIndex + 1}`,
                    source: 'boa',
                    is_boa: true,
                    params: {}  // Params can be added for component configuration
                };
                
                if (slotIndex < this.newNeg.negotiators.length) {
                    // Use splice for proper Alpine.js reactivity
                    this.newNeg.negotiators.splice(slotIndex, 1, boaNeg);
                } else {
                    this.newNeg.negotiators.push(boaNeg);
                }
                
                // Auto-advance to next slot if there's room
                const requiredCount = this.newNeg.scenario?.n_negotiators || 2;
                if (slotIndex + 1 < requiredCount && slotIndex + 1 < this.newNeg.negotiators.length) {
                    this.selectedNegotiatorSlot = slotIndex + 1;
                }
            },
            
            addMapModel() {
                const select = this.$refs.mapModelSelect;
                if (select && select.value && !this.mapConfig.models.includes(select.value)) {
                    this.mapConfig.models.push(select.value);
                    select.value = '';  // Reset selection
                }
            },
            
            applyMAPToSlot() {
                if (!this.mapConfig.acceptance_policy || !this.mapConfig.offering_policy) return;
                
                const slotIndex = this.selectedNegotiatorSlot;
                const existingName = this.newNeg.negotiators[slotIndex]?.name;
                
                // Build type_name: MAP:Accept/Offer
                const typeName = `MAP:${this.mapConfig.acceptance_policy}/${this.mapConfig.offering_policy}`;
                
                const mapNeg = {
                    type_name: typeName,
                    name: existingName || `Agent${slotIndex + 1}`,
                    source: 'map',
                    is_map: true,
                    params: {
                        models: [...this.mapConfig.models],
                        extra_components: [...this.mapConfig.extra_components],
                        acceptance_first: this.mapConfig.acceptance_first
                    }
                };
                
                if (slotIndex < this.newNeg.negotiators.length) {
                    // Use splice for proper Alpine.js reactivity
                    this.newNeg.negotiators.splice(slotIndex, 1, mapNeg);
                } else {
                    this.newNeg.negotiators.push(mapNeg);
                }
                
                // Auto-advance to next slot if there's room
                const requiredCount = this.newNeg.scenario?.n_negotiators || 2;
                if (slotIndex + 1 < requiredCount && slotIndex + 1 < this.newNeg.negotiators.length) {
                    this.selectedNegotiatorSlot = slotIndex + 1;
                }
            },
            
            // Start negotiation
            async startNegotiation() {
                if (!this.canStart) return;
                
                // Check outcome limit from performance settings
                const maxOutcomes = this.settings.maxOutcomesRun;
                if (maxOutcomes && maxOutcomes > 0 && this.newNeg.scenario?.n_outcomes) {
                    if (this.newNeg.scenario.n_outcomes > maxOutcomes) {
                        alert(`Cannot start negotiation: Scenario "${this.newNeg.scenario.name}" has ${this.newNeg.scenario.n_outcomes.toLocaleString()} outcomes, which exceeds the configured limit of ${maxOutcomes.toLocaleString()}.\n\nYou can change this limit in Settings > Performance.`);
                        return;
                    }
                }
                
                // Check if any negotiator requires the Genius Bridge
                const needsBridge = this.newNeg.negotiators.some(n => n.requires_bridge);
                if (needsBridge) {
                    // Refresh Genius Bridge status before checking
                    await this.checkGeniusBridgeStatus();
                    if (!this.geniusBridge.running) {
                        // Try to start the bridge
                        await this.startGeniusBridge();
                        if (!this.geniusBridge.running) {
                            alert('Cannot start negotiation: Genius Bridge is required but failed to start.');
                            return;
                        }
                    }
                }
                
                // Save to recent sessions
                await this.addToRecentSessions();
                
                // Build request with mechanism params
                const params = this.newNeg.mechanism_params || {};
                
                try {
                    const res = await fetch('/api/negotiation/start', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            scenario_path: this.newNeg.scenario.path,
                            negotiators: this.newNeg.negotiators,
                            mechanism_type: this.newNeg.mechanism_type,
                            mechanism_params: params,
                            step_delay: this.newNeg.step_delay / 1000,
                            share_ufuns: this.newNeg.share_ufuns,
                            ignore_discount: this.newNeg.ignore_discount,
                            ignore_reserved: this.newNeg.ignore_reserved,
                            normalize: this.newNeg.normalize,
                            auto_save: this.newNeg.auto_save
                        })
                    });
                    
                    const data = await res.json();
                    
                    // Add to running negotiations with panel settings
                    this.runningNegotiations.push({
                        id: data.session_id,
                        scenario: this.newNeg.scenario.name,
                        step: 0,
                        mechanism_type: this.newNeg.mechanism_type,
                        stream_url: data.stream_url,
                        // Store display settings with the negotiation
                        panelSettings: {
                            adjustable: this.newNeg.panels.adjustable,
                            utilityView: { ...this.newNeg.panels.utilityView },
                            timeline: { ...this.newNeg.panels.timeline }
                        },
                        mode: this.newNeg.mode,
                        show_plot: this.newNeg.show_plot,
                        show_offers: this.newNeg.show_offers
                    });
                    
                    this.showNewNegotiation = false;
                    
                    // Switch to negotiations page to see the running negotiation
                    this.currentPage = 'negotiations';
                    
                    // Start streaming (this will also auto-select the negotiation in index.html)
                    this.connectToStream(data.session_id, data.stream_url);
                    
                } catch (e) {
                    console.error('Failed to start negotiation:', e);
                }
            },
            
            connectToStream(sessionId, url) {
                const eventSource = new EventSource(url);
                
                eventSource.addEventListener('offer', (event) => {
                    const offer = JSON.parse(event.data);
                    const neg = this.runningNegotiations.find(n => n.id === sessionId);
                    if (neg) {
                        neg.step = offer.step;
                        neg.lastOffer = offer;
                    }
                });
                
                eventSource.addEventListener('complete', (event) => {
                    const result = JSON.parse(event.data);
                    const idx = this.runningNegotiations.findIndex(n => n.id === sessionId);
                    if (idx >= 0) {
                        const neg = this.runningNegotiations.splice(idx, 1)[0];
                        neg.agreement = result.agreement;
                        neg.final_utilities = result.final_utilities;
                        // Always set end_reason for completed negotiations
                        neg.end_reason = result.end_reason || (result.error ? 'error' : (result.agreement ? 'agreement' : 'completed'));
                        neg.error = result.error;
                        neg.optimality_stats = result.optimality_stats;
                        this.completedNegotiations.unshift(neg);
                    }
                    eventSource.close();
                });
                
                eventSource.addEventListener('error', () => {
                    eventSource.close();
                });
            },
            
            selectNegotiation(neg) {
                // If neg is from Tabulator (plain object copy), find the actual object by ID
                // to preserve the offers array and other properties
                if (neg && neg.id) {
                    const actualNeg = this.runningNegotiations.find(n => n.id === neg.id) 
                        || this.completedNegotiations.find(n => n.id === neg.id)
                        || neg;
                    this.currentNegotiation = actualNeg;
                } else {
                    this.currentNegotiation = neg;
                }
            },
            
            // Tournament methods
            async loadTournamentSessions() {
                try {
                    const res = await fetch('/api/tournament/sessions/list');
                    const data = await res.json();
                    this.tournamentSessions = data.sessions || [];
                    
                    // Split into running and completed
                    this.runningTournaments = this.tournamentSessions.filter(t => t.status === 'running');
                    this.completedTournaments = this.tournamentSessions.filter(t => t.status !== 'running');
                    
                    // Update tables if they exist
                    if (this._runningTournamentsTable) {
                        this._runningTournamentsTable.setData(this.runningTournaments);
                    }
                    if (this._completedTournamentsTable) {
                        this._completedTournamentsTable.setData(this.completedTournaments);
                    }
                } catch (e) {
                    console.error('Failed to load tournament sessions:', e);
                }
            },
            
            selectTournament(session) {
                this.selectedTournament = session;
                // If running, connect to stream
                if (session.status === 'running') {
                    this.connectToTournamentStream(session.id);
                }
            },
            
            async startTournament() {
                if (this.newTournament.competitor_types.length < 1) {
                    alert('Please select at least 1 competitor');
                    return;
                }
                if (this.newTournament.scenario_paths.length < 1) {
                    alert('Please select at least 1 scenario');
                    return;
                }
                
                // Validate opponents configuration
                if (this.newTournament.opponents_same_as_competitors) {
                    if (this.newTournament.competitor_types.length < 2) {
                        alert('When opponents are same as competitors, you need at least 2 competitors');
                        return;
                    }
                } else {
                    if (this.newTournament.opponent_types.length < 1) {
                        alert('Please select at least 1 opponent or check "Same as competitors"');
                        return;
                    }
                }
                
                // Check outcome limit from performance settings and filter out over-limit scenarios
                const maxOutcomes = this.settings.maxOutcomesRun;
                if (maxOutcomes && maxOutcomes > 0) {
                    const overLimitScenarios = [];
                    const validScenarios = [];
                    
                    for (const path of this.newTournament.scenario_paths) {
                        const scenario = this.scenarios.find(s => s.path === path);
                        if (scenario && scenario.n_outcomes && scenario.n_outcomes > maxOutcomes) {
                            overLimitScenarios.push({
                                name: scenario.name,
                                n_outcomes: scenario.n_outcomes
                            });
                        } else {
                            validScenarios.push(path);
                        }
                    }
                    
                    if (overLimitScenarios.length > 0) {
                        const scenarioList = overLimitScenarios
                            .map(s => `  - ${s.name} (${s.n_outcomes.toLocaleString()} outcomes)`)
                            .join('\n');
                        
                        if (validScenarios.length === 0) {
                            alert(`Cannot start tournament: All selected scenarios exceed the outcome limit of ${maxOutcomes.toLocaleString()}.\n\nScenarios removed:\n${scenarioList}\n\nYou can change this limit in Settings > Performance.`);
                            return;
                        }
                        
                        const proceed = confirm(`Warning: ${overLimitScenarios.length} scenario(s) exceed the outcome limit of ${maxOutcomes.toLocaleString()} and will be removed from the tournament:\n\n${scenarioList}\n\nRemaining scenarios: ${validScenarios.length}\n\nDo you want to continue with the remaining scenarios?`);
                        
                        if (!proceed) {
                            return;
                        }
                        
                        // Update the scenario paths to only include valid ones
                        this.newTournament.scenario_paths = validScenarios;
                    }
                }
                
                try {
                    // Prepare config, converting range fields to arrays if enabled
                    const config = { ...this.newTournament };
                    
                    // Handle opponent_types: null means same as competitors
                    if (config.opponents_same_as_competitors) {
                        config.opponent_types = null;
                    }
                    delete config.opponents_same_as_competitors;
                    
                    // Convert n_steps to range array if enabled
                    if (config.n_steps_range_enabled && config.n_steps_min && config.n_steps_max) {
                        config.n_steps = [config.n_steps_min, config.n_steps_max];
                    }
                    delete config.n_steps_range_enabled;
                    delete config.n_steps_min;
                    delete config.n_steps_max;
                    
                    // Convert time_limit to range array if enabled
                    if (config.time_limit_range_enabled && config.time_limit_min && config.time_limit_max) {
                        config.time_limit = [config.time_limit_min, config.time_limit_max];
                    }
                    delete config.time_limit_range_enabled;
                    delete config.time_limit_min;
                    delete config.time_limit_max;
                    
                    const res = await fetch('/api/tournament/start', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(config)
                    });
                    
                    const data = await res.json();
                    this.showNewTournament = false;
                    
                    // Add to sessions list
                    const newSession = {
                        id: data.session_id,
                        status: 'running',
                        config: { ...this.newTournament },
                        progress: { completed: 0, total: 0, percent: 0 }
                    };
                    this.tournamentSessions.unshift(newSession);
                    this.selectedTournament = newSession;
                    
                    // Connect to stream
                    this.connectToTournamentStream(data.session_id);
                    
                    // Reset form
                    this.resetTournamentForm();
                } catch (e) {
                    console.error('Failed to start tournament:', e);
                    alert('Failed to start tournament: ' + e.message);
                }
            },
            
            connectToTournamentStream(sessionId) {
                // Close existing connection
                if (this.tournamentEventSource) {
                    this.tournamentEventSource.close();
                }
                
                // Reset grid state
                this.tournamentGrid = {
                    competitors: [],
                    opponents: [],
                    scenarios: [],
                    cells: {},
                    currentScenarioIdx: 0,
                    n_repetitions: 1,
                    rotate_ufuns: false,
                };
                this.tournamentLeaderboard = [];
                this.tournamentLiveNegotiations = [];  // Reset live negotiations list
                this.tournamentSetupProgress = null;  // Reset setup progress
                
                this.tournamentEventSource = new EventSource(`/api/tournament/${sessionId}/stream`);
                
                // Handle setup progress (before negotiations start)
                this.tournamentEventSource.addEventListener('setup_progress', (event) => {
                    const data = JSON.parse(event.data);
                    this.tournamentSetupProgress = data;
                });
                
                // Handle grid initialization
                this.tournamentEventSource.addEventListener('grid_init', (event) => {
                    const data = JSON.parse(event.data);
                    // Clear setup progress when grid is initialized
                    this.tournamentSetupProgress = null;
                    this.tournamentGrid.competitors = data.competitors;
                    this.tournamentGrid.opponents = data.opponents;
                    this.tournamentGrid.scenarios = data.scenarios;
                    this.tournamentGrid.n_repetitions = data.n_repetitions;
                    this.tournamentGrid.rotate_ufuns = data.rotate_ufuns;
                    this.tournamentGrid.cells = {};
                    // Initialize all cells as pending
                    for (let i = 0; i < data.competitors.length; i++) {
                        for (let j = 0; j < data.opponents.length; j++) {
                            for (let s = 0; s < data.scenarios.length; s++) {
                                for (let r = 0; r < data.n_repetitions; r++) {
                                    const key = `${i}-${j}-${s}-${r}-false`;
                                    this.tournamentGrid.cells[key] = { status: 'pending' };
                                    if (data.rotate_ufuns) {
                                        const keyRot = `${i}-${j}-${s}-${r}-true`;
                                        this.tournamentGrid.cells[keyRot] = { status: 'pending' };
                                    }
                                }
                            }
                        }
                    }
                });
                
                // Handle cell start (running)
                this.tournamentEventSource.addEventListener('cell_start', (event) => {
                    const data = JSON.parse(event.data);
                    const key = `${data.competitor_idx}-${data.opponent_idx}-${data.scenario_idx}-${data.repetition}-${data.rotated}`;
                    this.tournamentGrid.cells[key] = { status: 'running' };
                });
                
                // Handle cell complete
                this.tournamentEventSource.addEventListener('cell_complete', (event) => {
                    const data = JSON.parse(event.data);
                    const key = `${data.competitor_idx}-${data.opponent_idx}-${data.scenario_idx}-${data.repetition}-${data.rotated}`;
                    this.tournamentGrid.cells[key] = {
                        status: 'complete',
                        end_reason: data.end_reason,
                        utilities: data.utilities,
                        error: data.error,
                    };
                    
                    // Add to live negotiations list
                    const competitor = this.tournamentGrid.competitors[data.competitor_idx];
                    const opponent = this.tournamentGrid.opponents[data.opponent_idx];
                    const scenario = this.tournamentGrid.scenarios[data.scenario_idx];
                    const partners = data.rotated ? [opponent, competitor] : [competitor, opponent];
                    const hasAgreement = data.end_reason === 'agreement';
                    const hasError = data.end_reason === 'error' || data.end_reason === 'broken';
                    
                    this.tournamentLiveNegotiations.push({
                        index: this.tournamentLiveNegotiations.length,
                        scenario: scenario,
                        scenario_path: data.scenario_path,
                        partners: partners,
                        has_agreement: hasAgreement,
                        has_error: hasError,
                        utilities: data.utilities,
                        end_reason: data.end_reason,
                        error_details: data.error,
                        repetition: data.repetition,
                        rotated: data.rotated,
                        competitor_idx: data.competitor_idx,
                        opponent_idx: data.opponent_idx,
                        scenario_idx: data.scenario_idx,
                        // Detailed negotiation data for viewing
                        issue_names: data.issue_names,
                        n_steps: data.n_steps,
                        agreement: data.agreement,
                        offers: data.offers || [],
                    });
                });
                
                // Handle leaderboard update
                this.tournamentEventSource.addEventListener('leaderboard', (event) => {
                    const data = JSON.parse(event.data);
                    this.tournamentLeaderboard = data;
                });
                
                this.tournamentEventSource.addEventListener('progress', (event) => {
                    const progress = JSON.parse(event.data);
                    const session = this.tournamentSessions.find(s => s.id === sessionId);
                    if (session) {
                        session.progress = progress;
                        session.status = 'running';
                    }
                    if (this.selectedTournament?.id === sessionId) {
                        this.selectedTournament.progress = progress;
                        this.selectedTournament.status = 'running';
                    }
                });
                
                this.tournamentEventSource.addEventListener('complete', async (event) => {
                    const result = JSON.parse(event.data);
                    const session = this.tournamentSessions.find(s => s.id === sessionId);
                    if (session) {
                        session.status = result.status;
                        session.results = result.results;
                        session.error = result.error;
                    }
                    if (this.selectedTournament?.id === sessionId) {
                        this.selectedTournament.status = result.status;
                        this.selectedTournament.results = result.results;
                        this.selectedTournament.error = result.error;
                    }
                    // Update running/completed arrays
                    this.runningTournaments = this.tournamentSessions.filter(t => t.status === 'running');
                    this.completedTournaments = this.tournamentSessions.filter(t => t.status !== 'running');
                    if (this._runningTournamentsTable) {
                        this._runningTournamentsTable.setData(this.runningTournaments);
                    }
                    if (this._completedTournamentsTable) {
                        this._completedTournamentsTable.setData(this.completedTournaments);
                    }
                    this.tournamentEventSource.close();
                    this.tournamentEventSource = null;
                    
                    // Refresh saved tournaments list to show the newly completed tournament
                    await this.loadSavedTournaments();
                    
                    // If results_path is available, load enriched data from saved files
                    if (result.results?.results_path && this.selectedTournament?.id === sessionId) {
                        try {
                            // Extract tournament ID from results_path (format: .../tournaments/{id})
                            const pathMatch = result.results.results_path.match(/tournaments\/([^\/]+)/);
                            if (pathMatch) {
                                const savedId = pathMatch[1];
                                // Load saved tournament data to enrich the current view
                                const res = await fetch(`/api/tournament/saved/${savedId}`);
                                if (res.ok) {
                                    const savedData = await res.json();
                                    // Enrich the current tournament with saved data
                                    this.selectedTournament._fromSaved = true;
                                    this.selectedTournament.path = savedData.path;
                                    this.selectedTournament.scores = savedData.scores || [];
                                    this.selectedTournament.negotiations = savedData.negotiations || [];
                                    this.selectedTournament.n_scenarios = savedData.n_scenarios;
                                    this.selectedTournament.n_competitors = savedData.n_competitors;
                                    this.selectedTournament.n_negotiations = savedData.n_negotiations;
                                    this.selectedTournament.n_agreements = savedData.n_agreements;
                                    this.selectedTournament.agreement_rate = savedData.agreement_rate;
                                    
                                    // Also update results.final_scores with enriched data
                                    if (savedData.scores?.length > 0) {
                                        this.selectedTournament.results.final_scores = savedData.scores.map((s, idx) => ({
                                            name: s.name,
                                            rank: s.rank,
                                            score: s.score,
                                            type_name: s.raw_data?.type || s.name,
                                            mean_utility: s.mean_utility ?? (s.raw_data?.utility ? parseFloat(s.raw_data.utility) : null),
                                            n_negotiations: s.n_negotiations ?? (s.raw_data?.n_negotiations ? parseInt(s.raw_data.n_negotiations) : null),
                                            n_agreements: s.raw_data?.n_agreements ? parseInt(s.raw_data.n_agreements) : null,
                                            mean_advantage: s.mean_advantage,
                                            mean_welfare: s.mean_welfare,
                                            mean_nash_optimality: s.mean_nash_optimality,
                                            mean_pareto_optimality: s.mean_pareto_optimality,
                                            type_scores: s.type_scores
                                        }));
                                    }
                                    
                                    // Load raw data and score analysis
                                    this.loadTournamentRawData(savedId);
                                    this.loadScoreAnalysis(savedId);
                                }
                            }
                        } catch (e) {
                            console.warn('Could not enrich completed tournament with saved data:', e);
                        }
                    }
                });
                
                this.tournamentEventSource.addEventListener('error', () => {
                    this.tournamentEventSource.close();
                    this.tournamentEventSource = null;
                });
            },
            
            async cancelTournament(sessionId) {
                try {
                    await fetch(`/api/tournament/${sessionId}/cancel`, { method: 'POST' });
                    const session = this.tournamentSessions.find(s => s.id === sessionId);
                    if (session) {
                        session.status = 'cancelled';
                    }
                    if (this.selectedTournament?.id === sessionId) {
                        this.selectedTournament.status = 'cancelled';
                    }
                    // Update running/completed arrays
                    this.runningTournaments = this.tournamentSessions.filter(t => t.status === 'running');
                    this.completedTournaments = this.tournamentSessions.filter(t => t.status !== 'running');
                    if (this._runningTournamentsTable) {
                        this._runningTournamentsTable.setData(this.runningTournaments);
                    }
                    if (this._completedTournamentsTable) {
                        this._completedTournamentsTable.setData(this.completedTournaments);
                    }
                } catch (e) {
                    console.error('Failed to cancel tournament:', e);
                }
            },
            
            async viewTournamentNegotiation(neg) {
                // View a negotiation from the tournament in detail
                // neg has: index, scenario, scenario_path, partners, has_agreement, agreement, utilities, 
                //          issue_names, n_steps, offers (for live/completed), etc.
                
                if (!neg) return;
                
                // For saved tournaments, use loadSavedNegotiationTrace
                if (this.selectedTournament?._fromSaved) {
                    await this.loadSavedNegotiationTrace(this.selectedTournament.id, neg.index);
                    return;
                }
                
                // For live/completed tournaments in current session, build negotiation from offers data
                const negotiatorNames = neg.partners || ['Negotiator 1', 'Negotiator 2'];
                const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6'];
                const negotiatorColors = negotiatorNames.map((_, idx) => colors[idx % colors.length]);
                
                // Convert offers to the format expected by the negotiation viewer
                const offers = [];
                const issueNames = neg.issue_names || [];
                
                if (neg.offers && neg.offers.length > 0) {
                    for (const offer of neg.offers) {
                        // Convert offer array to object with issue names as keys
                        const offerObj = {};
                        if (offer.offer_dict) {
                            Object.assign(offerObj, offer.offer_dict);
                        } else if (offer.offer && issueNames.length > 0) {
                            issueNames.forEach((name, idx) => {
                                offerObj[name] = offer.offer[idx];
                            });
                        }
                        
                        offers.push({
                            step: offer.step,
                            proposer: offer.proposer || negotiatorNames[offer.proposer_index] || `Negotiator ${offer.proposer_index}`,
                            proposer_index: offer.proposer_index,
                            offer: offerObj,
                            utilities: offer.utilities || neg.utilities || [0, 0],
                            time: 0,
                            relative_time: offer.step / (neg.n_steps || 100)
                        });
                    }
                }
                
                // Determine final step and agreement
                const lastStep = offers.length > 0 ? Math.max(...offers.map(o => o.step)) : 0;
                const hasAgreement = neg.has_agreement || false;
                
                // Build agreement object from tuple
                let agreementObj = null;
                if (hasAgreement && neg.agreement && issueNames.length > 0) {
                    agreementObj = {};
                    issueNames.forEach((name, idx) => {
                        agreementObj[name] = neg.agreement[idx];
                    });
                }
                
                // Try to load outcome_space_data from the scenario if results_path is available
                let outcomeSpaceData = null;
                const resultsPath = this.selectedTournament?.results?.results_path;
                if (resultsPath && neg.scenario) {
                    try {
                        // Extract tournament ID from results path (format: ~/negmas/app/tournaments/{id}/)
                        const pathMatch = resultsPath.match(/tournaments\/([^\/]+)/);
                        if (pathMatch) {
                            const tournamentId = pathMatch[1];
                            const scenarioRes = await fetch(`/api/tournament/saved/${tournamentId}/scenario/${neg.scenario}`);
                            if (scenarioRes.ok) {
                                const scenarioData = await scenarioRes.json();
                                outcomeSpaceData = scenarioData.outcome_space_data || null;
                            }
                        }
                    } catch (e) {
                        console.warn('Could not load outcome_space_data for live tournament negotiation:', e);
                    }
                }
                
                // Create a complete negotiation object matching the viewer's expectations
                const negotiation = {
                    id: `tournament-${this.selectedTournament?.id}-${neg.index}`,
                    scenario: neg.scenario || 'Unknown',
                    scenario_path: neg.scenario_path,
                    step: lastStep,
                    n_steps: neg.n_steps || null,
                    relative_time: 1.0,
                    offers: offers,
                    negotiator_names: negotiatorNames,
                    negotiator_colors: negotiatorColors,
                    agreement: agreementObj,
                    final_utilities: neg.utilities || null,
                    end_reason: hasAgreement ? 'agreement' : (neg.has_error ? 'error' : 'no_agreement'),
                    mechanism_type: 'SAOMechanism',
                    // Include outcome_space_data for 2D utility visualization
                    outcome_space_data: outcomeSpaceData,
                    // Mark this as from tournament so we can navigate back
                    isSaved: true,
                    isFromTournament: true,
                    tournamentId: this.selectedTournament?.id,
                    pendingStart: false,
                    paused: false
                };
                
                // Store reference to return to tournament
                this._returnToTournament = this.selectedTournament;
                
                // Switch to negotiations page and set as current
                this.currentPage = 'negotiations';
                this.currentNegotiation = negotiation;
                
                // Initialize plots after DOM updates
                this.$nextTick(() => {
                    this.initOutcomeSpacePlot();
                    this.initUtilityTimelinePlots();
                    this.initHistogramPlot();
                });
            },
            
            // Tournament grid helper methods
            getCellKey(i, j, s, r, rotated) {
                return `${i}-${j}-${s}-${r || 0}-${rotated || false}`;
            },
            
            // Get status for a specific scenario's cell
            getScenarioCellStatus(i, j) {
                const s = this.tournamentGrid.currentTab;
                if (s === 'summary') return 'pending';
                
                let hasRunning = false;
                let hasComplete = false;
                let allPending = true;
                let lastEndReason = null;
                
                for (let r = 0; r < this.tournamentGrid.n_repetitions; r++) {
                    const key = this.getCellKey(i, j, s, r, false);
                    const cell = this.tournamentGrid.cells[key];
                    if (cell) {
                        if (cell.status === 'running') hasRunning = true;
                        if (cell.status === 'complete') {
                            hasComplete = true;
                            lastEndReason = cell.end_reason;
                        }
                        if (cell.status !== 'pending') allPending = false;
                    }
                    
                    if (this.tournamentGrid.rotate_ufuns) {
                        const keyRot = this.getCellKey(i, j, s, r, true);
                        const cellRot = this.tournamentGrid.cells[keyRot];
                        if (cellRot) {
                            if (cellRot.status === 'running') hasRunning = true;
                            if (cellRot.status === 'complete') {
                                hasComplete = true;
                                lastEndReason = cellRot.end_reason;
                            }
                            if (cellRot.status !== 'pending') allPending = false;
                        }
                    }
                }
                
                if (hasRunning) return 'running';
                if (hasComplete) return lastEndReason || 'complete';
                if (allPending) return 'pending';
                return 'pending';
            },
            
            getScenarioCellClass(i, j) {
                const status = this.getScenarioCellStatus(i, j);
                if (i === j && !this.newTournament.self_play) {
                    return 'self-play';
                }
                return status;
            },
            
            // Summary cell: aggregate across ALL scenarios
            getSummaryCellStats(i, j) {
                const nScenarios = this.tournamentGrid.scenarios.length;
                const nReps = this.tournamentGrid.n_repetitions;
                const rotateMultiplier = this.tournamentGrid.rotate_ufuns ? 2 : 1;
                const totalPossible = nScenarios * nReps * rotateMultiplier;
                
                let completed = 0;
                let hasError = false;
                let running = false;
                
                for (let s = 0; s < nScenarios; s++) {
                    for (let r = 0; r < nReps; r++) {
                        const key = this.getCellKey(i, j, s, r, false);
                        const cell = this.tournamentGrid.cells[key];
                        if (cell) {
                            if (cell.status === 'complete') {
                                completed++;
                                if (cell.end_reason === 'error' || cell.end_reason === 'broken') {
                                    hasError = true;
                                }
                            }
                            if (cell.status === 'running') running = true;
                        }
                        
                        if (this.tournamentGrid.rotate_ufuns) {
                            const keyRot = this.getCellKey(i, j, s, r, true);
                            const cellRot = this.tournamentGrid.cells[keyRot];
                            if (cellRot) {
                                if (cellRot.status === 'complete') {
                                    completed++;
                                    if (cellRot.end_reason === 'error' || cellRot.end_reason === 'broken') {
                                        hasError = true;
                                    }
                                }
                                if (cellRot.status === 'running') running = true;
                            }
                        }
                    }
                }
                
                return { completed, totalPossible, hasError, running };
            },
            
            getSummaryCellStyle(i, j) {
                if (i === j && !this.newTournament.self_play) {
                    return 'background: var(--bg-tertiary);';
                }
                
                const { completed, totalPossible, hasError, running } = this.getSummaryCellStats(i, j);
                const ratio = totalPossible > 0 ? completed / totalPossible : 0;
                
                if (running) {
                    // Currently running - show with a pulsing border
                    const baseColor = hasError ? 'rgba(220, 53, 69, ' : 'rgba(40, 167, 69, ';
                    const alpha = Math.max(0.1, ratio * 0.8);
                    return `background: ${baseColor}${alpha}); box-shadow: inset 0 0 0 2px var(--primary);`;
                }
                
                if (completed === 0) {
                    return 'background: var(--bg-secondary);';
                }
                
                // Color based on completion ratio: white -> green (or red if errors)
                const baseColor = hasError ? 'rgba(220, 53, 69, ' : 'rgba(40, 167, 69, ';
                const alpha = Math.max(0.15, ratio * 0.85);
                return `background: ${baseColor}${alpha});`;
            },
            
            getSummaryCellPercent(i, j) {
                if (i === j && !this.newTournament.self_play) {
                    return '-';
                }
                
                const { completed, totalPossible } = this.getSummaryCellStats(i, j);
                if (totalPossible === 0) return '0%';
                const percent = Math.round((completed / totalPossible) * 100);
                return percent + '%';
            },
            
            // Legacy methods for backward compatibility
            getCellStatus(i, j) {
                return this.getScenarioCellStatus(i, j);
            },
            
            getCellClass(i, j) {
                return this.getScenarioCellClass(i, j);
            },
            
            switchTournamentScenario(idx) {
                this.tournamentGrid.currentTab = idx;
            },
            
            toggleTournamentScenario(scenarioPath) {
                const idx = this.newTournament.scenario_paths.indexOf(scenarioPath);
                if (idx >= 0) {
                    this.newTournament.scenario_paths.splice(idx, 1);
                } else {
                    this.newTournament.scenario_paths.push(scenarioPath);
                }
            },
            
            toggleTournamentCompetitor(typeName) {
                const idx = this.newTournament.competitor_types.indexOf(typeName);
                if (idx >= 0) {
                    this.newTournament.competitor_types.splice(idx, 1);
                } else {
                    this.newTournament.competitor_types.push(typeName);
                }
            },
            
            // New dual-list helper methods for scenarios
            addTournamentScenario(scenarioPath) {
                if (!this.newTournament.scenario_paths.includes(scenarioPath)) {
                    this.newTournament.scenario_paths.push(scenarioPath);
                }
            },
            
            removeTournamentScenario(scenarioPath) {
                const idx = this.newTournament.scenario_paths.indexOf(scenarioPath);
                if (idx >= 0) {
                    this.newTournament.scenario_paths.splice(idx, 1);
                }
            },
            
            addAllFilteredTournamentScenarios() {
                const filtered = this.filteredTournamentScenarios;
                for (const s of filtered) {
                    if (!this.newTournament.scenario_paths.includes(s.path)) {
                        this.newTournament.scenario_paths.push(s.path);
                    }
                }
            },
            
            // New dual-list helper methods for competitors
            addTournamentCompetitor(typeName) {
                if (!this.newTournament.competitor_types.includes(typeName)) {
                    this.newTournament.competitor_types.push(typeName);
                }
            },
            
            removeTournamentCompetitor(typeName) {
                const idx = this.newTournament.competitor_types.indexOf(typeName);
                if (idx >= 0) {
                    this.newTournament.competitor_types.splice(idx, 1);
                }
            },
            
            // Dual-list helper methods for opponents
            addTournamentOpponent(typeName) {
                if (!this.newTournament.opponent_types.includes(typeName)) {
                    this.newTournament.opponent_types.push(typeName);
                }
            },
            
            removeTournamentOpponent(typeName) {
                const idx = this.newTournament.opponent_types.indexOf(typeName);
                if (idx >= 0) {
                    this.newTournament.opponent_types.splice(idx, 1);
                }
            },
            
            isTournamentOpponentSelected(typeName) {
                return this.newTournament.opponent_types.includes(typeName);
            },
            
            addAllFilteredTournamentOpponents() {
                const available = this.filteredTournamentOpponents.filter(
                    n => !this.isTournamentOpponentSelected(n.type_name)
                );
                for (const neg of available) {
                    this.newTournament.opponent_types.push(neg.type_name);
                }
            },
            
            // Tournament wizard navigation
            tournamentWizardNext() {
                const tabs = ['scenarios', 'competitors', 'opponents', 'settings', 'review'];
                const currentIdx = tabs.indexOf(this.tournamentTab);
                if (currentIdx < tabs.length - 1) {
                    this.tournamentTab = tabs[currentIdx + 1];
                }
            },
            
            tournamentWizardBack() {
                const tabs = ['scenarios', 'competitors', 'opponents', 'settings', 'review'];
                const currentIdx = tabs.indexOf(this.tournamentTab);
                if (currentIdx > 0) {
                    this.tournamentTab = tabs[currentIdx - 1];
                }
            },
            
            canStartTournament() {
                const hasScenarios = this.newTournament.scenario_paths.length >= 1;
                const hasCompetitors = this.newTournament.competitor_types.length >= 1;
                // If opponents same as competitors, need at least 2 competitors
                // If separate opponents, need at least 1 opponent
                const hasValidOpponents = this.newTournament.opponents_same_as_competitors
                    ? this.newTournament.competitor_types.length >= 2
                    : this.newTournament.opponent_types.length >= 1;
                return hasScenarios && hasCompetitors && hasValidOpponents;
            },
            
            estimateTournamentPairings() {
                const nCompetitors = this.newTournament.competitor_types.length;
                
                if (this.newTournament.opponents_same_as_competitors) {
                    // Standard mode: competitors play each other
                    if (nCompetitors < 2) return 0;
                    if (this.newTournament.self_play) {
                        return nCompetitors * nCompetitors;  // All combinations including self
                    } else {
                        return nCompetitors * (nCompetitors - 1);
                    }
                } else {
                    // Separate opponents mode: competitors play against opponents
                    const nOpponents = this.newTournament.opponent_types.length;
                    if (nCompetitors < 1 || nOpponents < 1) return 0;
                    return nCompetitors * nOpponents;
                }
            },
            
            estimateTournamentNegotiations() {
                const scenarios = this.newTournament.scenario_paths.length;
                const pairings = this.estimateTournamentPairings();
                const reps = this.newTournament.n_repetitions || 1;
                const rotateMultiplier = this.newTournament.rotate_ufuns ? 2 : 1;
                return scenarios * pairings * reps * rotateMultiplier;
            },
            
            // Tournament preset methods
            async loadTournamentPresets() {
                try {
                    const res = await fetch('/api/settings/presets/tournaments');
                    const data = await res.json();
                    this.tournamentPresets = data.presets || [];
                } catch (err) {
                    console.error('Error loading tournament presets:', err);
                    this.tournamentPresets = [];
                }
            },
            
            async saveTournamentPreset() {
                if (!this.tournamentPresetName.trim()) return;
                
                try {
                    const preset = {
                        name: this.tournamentPresetName.trim(),
                        scenario_paths: this.newTournament.scenario_paths,
                        competitor_types: this.newTournament.competitor_types,
                        opponent_types: this.newTournament.opponents_same_as_competitors ? null : this.newTournament.opponent_types,
                        opponents_same_as_competitors: this.newTournament.opponents_same_as_competitors,
                        n_repetitions: this.newTournament.n_repetitions,
                        rotate_ufuns: this.newTournament.rotate_ufuns,
                        self_play: this.newTournament.self_play,
                        mechanism_type: this.newTournament.mechanism_type,
                        n_steps: this.newTournament.n_steps_range_enabled ? null : this.newTournament.n_steps,
                        n_steps_min: this.newTournament.n_steps_range_enabled ? this.newTournament.n_steps_min : null,
                        n_steps_max: this.newTournament.n_steps_range_enabled ? this.newTournament.n_steps_max : null,
                        time_limit: this.newTournament.time_limit_range_enabled ? null : this.newTournament.time_limit,
                        time_limit_min: this.newTournament.time_limit_range_enabled ? this.newTournament.time_limit_min : null,
                        time_limit_max: this.newTournament.time_limit_range_enabled ? this.newTournament.time_limit_max : null,
                        step_time_limit: this.newTournament.step_time_limit,
                        negotiator_time_limit: this.newTournament.negotiator_time_limit,
                        hidden_time_limit: this.newTournament.hidden_time_limit,
                        pend: this.newTournament.pend,
                        pend_per_second: this.newTournament.pend_per_second,
                        final_score_metric: this.newTournament.final_score_metric,
                        final_score_stat: this.newTournament.final_score_stat,
                        randomize_runs: this.newTournament.randomize_runs,
                        sort_runs: this.newTournament.sort_runs,
                        id_reveals_type: this.newTournament.id_reveals_type,
                        name_reveals_type: this.newTournament.name_reveals_type,
                        mask_scenario_names: this.newTournament.mask_scenario_names,
                        only_failures_on_self_play: this.newTournament.only_failures_on_self_play,
                        save_stats: this.newTournament.save_stats,
                        save_scenario_figs: this.newTournament.save_scenario_figs,
                        save_every: this.newTournament.save_every,
                        normalize: this.newTournament.normalize,
                    };
                    
                    await fetch('/api/settings/presets/tournaments', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(preset)
                    });
                    
                    await this.loadTournamentPresets();
                    this.selectedTournamentPreset = this.tournamentPresetName.trim();
                    this.tournamentPresetName = '';
                    this.showToast('Tournament preset saved');
                } catch (err) {
                    console.error('Error saving tournament preset:', err);
                    this.showToast('Error saving preset', 'error');
                }
            },
            
            async loadTournamentPreset() {
                if (!this.selectedTournamentPreset) return;
                
                const preset = this.tournamentPresets.find(p => p.name === this.selectedTournamentPreset);
                if (!preset) return;
                
                // Load scenario paths
                this.newTournament.scenario_paths = preset.scenario_paths || [];
                
                // Load competitor types
                this.newTournament.competitor_types = preset.competitor_types || [];
                
                // Load opponent types
                this.newTournament.opponents_same_as_competitors = preset.opponents_same_as_competitors ?? true;
                this.newTournament.opponent_types = preset.opponent_types || [];
                
                // Load basic settings
                this.newTournament.n_repetitions = preset.n_repetitions || 1;
                this.newTournament.rotate_ufuns = preset.rotate_ufuns ?? true;
                this.newTournament.self_play = preset.self_play ?? true;
                this.newTournament.mechanism_type = preset.mechanism_type || 'SAOMechanism';
                
                // Load steps settings
                if (preset.n_steps_min !== null && preset.n_steps_max !== null) {
                    this.newTournament.n_steps_range_enabled = true;
                    this.newTournament.n_steps_min = preset.n_steps_min;
                    this.newTournament.n_steps_max = preset.n_steps_max;
                    this.newTournament.n_steps = 100;
                } else {
                    this.newTournament.n_steps_range_enabled = false;
                    this.newTournament.n_steps = preset.n_steps || 100;
                }
                
                // Load time limit settings
                if (preset.time_limit_min !== null && preset.time_limit_max !== null) {
                    this.newTournament.time_limit_range_enabled = true;
                    this.newTournament.time_limit_min = preset.time_limit_min;
                    this.newTournament.time_limit_max = preset.time_limit_max;
                    this.newTournament.time_limit = null;
                } else {
                    this.newTournament.time_limit_range_enabled = false;
                    this.newTournament.time_limit = preset.time_limit;
                }
                
                // Load advanced settings
                this.newTournament.step_time_limit = preset.step_time_limit;
                this.newTournament.negotiator_time_limit = preset.negotiator_time_limit;
                this.newTournament.hidden_time_limit = preset.hidden_time_limit;
                this.newTournament.pend = preset.pend;
                this.newTournament.pend_per_second = preset.pend_per_second;
                this.newTournament.final_score_metric = preset.final_score_metric || 'advantage';
                this.newTournament.final_score_stat = preset.final_score_stat || 'mean';
                this.newTournament.randomize_runs = preset.randomize_runs ?? false;
                this.newTournament.sort_runs = preset.sort_runs ?? true;
                this.newTournament.id_reveals_type = preset.id_reveals_type ?? false;
                this.newTournament.name_reveals_type = preset.name_reveals_type ?? true;
                this.newTournament.mask_scenario_names = preset.mask_scenario_names ?? false;
                this.newTournament.only_failures_on_self_play = preset.only_failures_on_self_play ?? false;
                this.newTournament.save_stats = preset.save_stats ?? true;
                this.newTournament.save_scenario_figs = preset.save_scenario_figs ?? true;
                this.newTournament.save_every = preset.save_every ?? 1;
                this.newTournament.normalize = preset.normalize ?? true;
                
                // Navigate to review tab to let user review and start
                this.tournamentTab = 'review';
                
                this.showToast(`Loaded preset: ${preset.name}`);
            },
            
            async deleteTournamentPreset(name) {
                if (!confirm(`Delete tournament preset "${name}"?`)) return;
                
                try {
                    await fetch(`/api/settings/presets/tournaments/${encodeURIComponent(name)}`, {
                        method: 'DELETE'
                    });
                    await this.loadTournamentPresets();
                    if (this.selectedTournamentPreset === name) {
                        this.selectedTournamentPreset = '';
                    }
                    this.showToast('Tournament preset deleted');
                } catch (err) {
                    console.error('Error deleting tournament preset:', err);
                    this.showToast('Error deleting preset', 'error');
                }
            },
            
            // Virtual negotiator methods
            async loadVirtualNegotiators() {
                this.virtualNegotiatorsLoading = true;
                try {
                    const res = await fetch('/api/negotiators/virtual');
                    const data = await res.json();
                    this.virtualNegotiators = data.virtual_negotiators || [];
                } catch (err) {
                    console.error('Error loading virtual negotiators:', err);
                    this.virtualNegotiators = [];
                } finally {
                    this.virtualNegotiatorsLoading = false;
                }
            },
            
            isVirtualNegotiator(typeName) {
                return typeName && typeName.startsWith('virtual:');
            },
            
            getVirtualNegotiator(typeName) {
                if (!typeName || !typeName.startsWith('virtual:')) return null;
                const id = typeName.replace('virtual:', '');
                return this.virtualNegotiators.find(vn => vn.id === id);
            },
            
            // Virtual mechanism methods
            async loadVirtualMechanisms() {
                this.virtualMechanismsLoading = true;
                try {
                    const res = await fetch('/api/mechanisms/virtual');
                    const data = await res.json();
                    this.virtualMechanisms = data.virtual_mechanisms || [];
                } catch (err) {
                    console.error('Error loading virtual mechanisms:', err);
                    this.virtualMechanisms = [];
                } finally {
                    this.virtualMechanismsLoading = false;
                }
            },
            
            isVirtualMechanism(className) {
                return className && className.startsWith('virtual:');
            },
            
            getVirtualMechanism(className) {
                if (!className || !className.startsWith('virtual:')) return null;
                const id = className.replace('virtual:', '');
                return this.virtualMechanisms.find(vm => vm.id === id);
            },
            
            getBaseTypeFromVirtualMechanism(className) {
                const vm = this.getVirtualMechanism(className);
                if (!vm) return className;
                return vm.base_type === 'sao' ? 'SAOMechanism' : 
                       vm.base_type === 'tau' ? 'TAUMechanism' : 
                       vm.base_type === 'gb' ? 'GBMechanism' : vm.base_type;
            },
            
            openSaveVirtualMechanism() {
                this.saveVirtualMechanismName = '';
                this.saveVirtualMechanismDescription = '';
                this.saveVirtualMechanismTags = '';
                this.showSaveVirtualMechanism = true;
            },
            
            closeSaveVirtualMechanism() {
                this.showSaveVirtualMechanism = false;
            },
            
            async saveAsVirtualMechanism() {
                if (!this.saveVirtualMechanismName.trim()) {
                    alert('Please enter a name for the virtual mechanism');
                    return;
                }
                
                // Determine base_type from current mechanism
                const baseType = this.newNeg.mechanism_type === 'SAOMechanism' ? 'sao' :
                                 this.newNeg.mechanism_type === 'TAUMechanism' ? 'tau' :
                                 this.newNeg.mechanism_type === 'GBMechanism' ? 'gb' : 'sao';
                
                // Parse tags
                const tags = this.saveVirtualMechanismTags.trim() 
                    ? this.saveVirtualMechanismTags.split(',').map(t => t.trim()).filter(t => t)
                    : [];
                
                try {
                    const res = await fetch('/api/mechanisms/virtual', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            name: this.saveVirtualMechanismName.trim(),
                            base_type: baseType,
                            description: this.saveVirtualMechanismDescription.trim(),
                            tags: tags,
                            params: { ...this.newNeg.mechanism_params }
                        })
                    });
                    
                    if (!res.ok) {
                        const err = await res.json();
                        alert('Error creating virtual mechanism: ' + (err.detail || 'Unknown error'));
                        return;
                    }
                    
                    const data = await res.json();
                    const newVm = data.virtual_mechanism;
                    
                    // Add to virtual mechanisms list
                    this.virtualMechanisms.push(newVm);
                    
                    // Select the new virtual mechanism
                    this.selectMechanism('virtual:' + newVm.id);
                    
                    this.closeSaveVirtualMechanism();
                } catch (err) {
                    console.error('Error creating virtual mechanism:', err);
                    alert('Error creating virtual mechanism');
                }
            },
            
            async deleteVirtualMechanism(id) {
                if (!confirm('Are you sure you want to delete this virtual mechanism?')) {
                    return;
                }
                
                try {
                    const res = await fetch(`/api/mechanisms/virtual/${id}`, {
                        method: 'DELETE'
                    });
                    
                    if (!res.ok) {
                        const err = await res.json();
                        alert('Error deleting virtual mechanism: ' + (err.detail || 'Unknown error'));
                        return;
                    }
                    
                    // Remove from list
                    this.virtualMechanisms = this.virtualMechanisms.filter(vm => vm.id !== id);
                    
                    // If this was the selected mechanism, select the first base mechanism
                    if (this.newNeg.mechanism_type === 'virtual:' + id) {
                        this.selectMechanism('SAOMechanism');
                    }
                } catch (err) {
                    console.error('Error deleting virtual mechanism:', err);
                    alert('Error deleting virtual mechanism');
                }
            },
            
            async openCompetitorConfig(typeName) {
                this.competitorConfigTypeName = typeName;
                this.competitorConfigLoading = true;
                this.competitorConfigValues = {};
                this.competitorConfigSaveAsVirtual = false;
                this.competitorConfigVirtualName = '';
                this.showCompetitorConfig = true;
                
                // Determine the base type for parameter lookup
                let baseType = typeName;
                if (this.isVirtualNegotiator(typeName)) {
                    const vn = this.getVirtualNegotiator(typeName);
                    if (vn) {
                        baseType = vn.base_type_name;
                        // Pre-fill with virtual negotiator's saved params
                        this.competitorConfigValues = { ...vn.params };
                        this.competitorConfigVirtualName = vn.name;
                    }
                }
                
                try {
                    const res = await fetch(`/api/negotiators/${encodeURIComponent(baseType)}/parameters`);
                    const data = await res.json();
                    this.competitorConfigParams = data.parameters || [];
                    
                    // Set default values for params not already set
                    for (const param of this.competitorConfigParams) {
                        if (!(param.name in this.competitorConfigValues) && param.default !== null) {
                            this.competitorConfigValues[param.name] = param.default;
                        }
                    }
                } catch (err) {
                    console.error('Error loading negotiator parameters:', err);
                    this.competitorConfigParams = [];
                } finally {
                    this.competitorConfigLoading = false;
                }
            },
            
            closeCompetitorConfig() {
                this.showCompetitorConfig = false;
                this.competitorConfigTypeName = null;
                this.competitorConfigParams = [];
                this.competitorConfigValues = {};
            },
            
            async saveCompetitorConfig() {
                if (!this.competitorConfigSaveAsVirtual) {
                    // Just close without saving - params are stored in tournament config
                    // For now, we don't persist per-competitor params in tournament
                    // This would require extending the tournament data model
                    this.closeCompetitorConfig();
                    return;
                }
                
                // Create a new virtual negotiator
                if (!this.competitorConfigVirtualName.trim()) {
                    alert('Please enter a name for the virtual negotiator');
                    return;
                }
                
                // Determine the base type
                let baseType = this.competitorConfigTypeName;
                if (this.isVirtualNegotiator(this.competitorConfigTypeName)) {
                    const vn = this.getVirtualNegotiator(this.competitorConfigTypeName);
                    if (vn) baseType = vn.base_type_name;
                }
                
                try {
                    const res = await fetch('/api/negotiators/virtual', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            name: this.competitorConfigVirtualName.trim(),
                            base_type_name: baseType,
                            params: this.competitorConfigValues,
                            description: '',
                            tags: []
                        })
                    });
                    
                    if (!res.ok) {
                        const err = await res.json();
                        alert('Error creating virtual negotiator: ' + (err.detail || 'Unknown error'));
                        return;
                    }
                    
                    const data = await res.json();
                    const newVn = data.virtual_negotiator;
                    
                    // Add to virtual negotiators list
                    this.virtualNegotiators.push(newVn);
                    
                    // Replace the original type with the new virtual negotiator in the selection
                    const idx = this.newTournament.competitor_types.indexOf(this.competitorConfigTypeName);
                    if (idx >= 0) {
                        this.newTournament.competitor_types[idx] = 'virtual:' + newVn.id;
                    }
                    
                    this.closeCompetitorConfig();
                } catch (err) {
                    console.error('Error creating virtual negotiator:', err);
                    alert('Error creating virtual negotiator');
                }
            },
            
            addAllFilteredTournamentCompetitors() {
                const filtered = this.filteredTournamentCompetitors;
                for (const n of filtered) {
                    if (!this.newTournament.competitor_types.includes(n.type_name)) {
                        this.newTournament.competitor_types.push(n.type_name);
                    }
                }
            },
            
            isTournamentScenarioSelected(scenarioPath) {
                return this.newTournament.scenario_paths.includes(scenarioPath);
            },
            
            isTournamentCompetitorSelected(typeName) {
                return this.newTournament.competitor_types.includes(typeName);
            },
            
            resetTournamentForm() {
                this.newTournament = {
                    competitor_types: [],
                    opponent_types: [],
                    opponents_same_as_competitors: true,
                    scenario_paths: [],
                    n_repetitions: 1,
                    rotate_ufuns: true,
                    self_play: true,
                    mechanism_type: 'SAOMechanism',
                    n_steps: 100,
                    n_steps_range_enabled: false,
                    n_steps_min: 50,
                    n_steps_max: 200,
                    time_limit: null,
                    time_limit_range_enabled: false,
                    time_limit_min: 30,
                    time_limit_max: 120,
                    // Time limits for negotiators
                    step_time_limit: null,
                    negotiator_time_limit: null,
                    hidden_time_limit: null,
                    // Probabilistic ending
                    pend: null,
                    pend_per_second: null,
                    // Scoring
                    final_score_metric: 'advantage',
                    final_score_stat: 'mean',
                    // Run ordering
                    randomize_runs: false,
                    sort_runs: true,
                    // Information hiding
                    id_reveals_type: false,
                    name_reveals_type: true,
                    mask_scenario_names: false,
                    // Self-play options
                    only_failures_on_self_play: false,
                    // Save options
                    save_stats: true,
                    save_scenario_figs: true,
                    save_every: 1,
                };
                // Also reset search/filter fields
                this.tournamentScenarioSearch = '';
                this.tournamentScenarioSourceFilter = '';
                this.tournamentCompetitorSearch = '';
                this.tournamentCompetitorSourceFilter = '';
                this.tournamentCompetitorTagFilter = '';
                this.tournamentOpponentSearch = '';
                this.tournamentOpponentSourceFilter = '';
            },
            
            get filteredTournamentScenarios() {
                return this.applyScenarioFilters(
                    this.scenarios,
                    this.tournamentScenarioFilters,
                    this.tournamentScenarioSourceFilter,
                    this.tournamentScenarioSearch
                );
            },
            
            get filteredTournamentCompetitors() {
                // Combine regular negotiators with virtual negotiators
                const virtualAsNegotiators = this.virtualNegotiators.map(vn => ({
                    type_name: 'virtual:' + vn.id,
                    name: vn.name,
                    source: 'virtual',
                    group: '',
                    description: vn.description || `Based on ${vn.base_type_name.split('.').pop()}`,
                    tags: vn.tags,
                    mechanisms: ['SAO'],  // Assume SAO for now
                    requires_bridge: false,
                    available: true,
                    isVirtual: true
                }));
                
                let filtered = [...this.negotiatorTypes, ...virtualAsNegotiators];
                
                // Apply source filter
                if (this.tournamentCompetitorSourceFilter) {
                    filtered = filtered.filter(n => n.source === this.tournamentCompetitorSourceFilter);
                }
                
                // Apply tag filter
                if (this.tournamentCompetitorTagFilter) {
                    const tag = this.tournamentCompetitorTagFilter.toLowerCase();
                    filtered = filtered.filter(n => 
                        n.tags && n.tags.some(t => t.toLowerCase() === tag)
                    );
                }
                
                // Apply search filter
                if (this.tournamentCompetitorSearch) {
                    const search = this.tournamentCompetitorSearch.toLowerCase();
                    filtered = filtered.filter(n => 
                        n.name.toLowerCase().includes(search) ||
                        n.type_name.toLowerCase().includes(search) ||
                        (n.source && n.source.toLowerCase().includes(search))
                    );
                }
                
                return filtered;
            },
            
            get filteredTournamentOpponents() {
                // Combine regular negotiators with virtual negotiators (same as competitors)
                const virtualAsNegotiators = this.virtualNegotiators.map(vn => ({
                    type_name: 'virtual:' + vn.id,
                    name: vn.name,
                    source: 'virtual',
                    group: '',
                    description: vn.description || `Based on ${vn.base_type_name.split('.').pop()}`,
                    tags: vn.tags,
                    mechanisms: ['SAO'],
                    requires_bridge: false,
                    available: true,
                    isVirtual: true
                }));
                
                let filtered = [...this.negotiatorTypes, ...virtualAsNegotiators];
                
                // Apply source filter
                if (this.tournamentOpponentSourceFilter) {
                    filtered = filtered.filter(n => n.source === this.tournamentOpponentSourceFilter);
                }
                
                // Apply search filter
                if (this.tournamentOpponentSearch) {
                    const search = this.tournamentOpponentSearch.toLowerCase();
                    filtered = filtered.filter(n => 
                        n.name.toLowerCase().includes(search) ||
                        n.type_name.toLowerCase().includes(search) ||
                        (n.source && n.source.toLowerCase().includes(search))
                    );
                }
                
                return filtered;
            },
            
            // Saved tournament methods
            async loadSavedTournaments() {
                this.savedTournamentsLoading = true;
                try {
                    // Build query params
                    const params = new URLSearchParams();
                    if (this.tournamentTagFilter) params.append('tags', this.tournamentTagFilter);
                    if (!this.showArchivedTournaments) params.append('archived', 'false');
                    
                    const res = await fetch(`/api/tournament/saved/list?${params}`);
                    const data = await res.json();
                    this.savedTournaments = data.tournaments || [];
                    
                    // Extract available tags
                    const tagSet = new Set();
                    for (const t of this.savedTournaments) {
                        if (t.tags) {
                            for (const tag of t.tags) {
                                tagSet.add(tag);
                            }
                        }
                    }
                    this.availableTournamentTags = Array.from(tagSet).sort();
                    
                    // Update table if it exists
                    if (this._savedTournamentsTable) {
                        this._savedTournamentsTable.setData(this.savedTournaments);
                    }
                } catch (e) {
                    console.error('Failed to load saved tournaments:', e);
                } finally {
                    this.savedTournamentsLoading = false;
                }
            },
            
            async loadAndSelectSavedTournament(tournamentId) {
                try {
                    const res = await fetch(`/api/tournament/saved/${tournamentId}`);
                    if (!res.ok) throw new Error('Failed to load tournament');
                    const data = await res.json();
                    
                    // Transform to match our tournament format
                    this.selectedTournament = {
                        id: data.id,
                        status: 'completed',
                        _fromSaved: true,
                        path: data.path,
                        n_scenarios: data.n_scenarios,
                        n_competitors: data.n_competitors,
                        n_negotiations: data.n_negotiations,
                        n_agreements: data.n_agreements,
                        agreement_rate: data.agreement_rate,
                        created_at: data.created_at,
                        scores: data.scores || [],
                        negotiations: data.negotiations || [],
                        config: {
                            competitor_types: [],  // Not available from saved data
                            scenario_paths: []
                        },
                        results: {
                            total_negotiations: data.n_negotiations,
                            total_agreements: data.n_agreements,
                            overall_agreement_rate: data.agreement_rate,
                            execution_time: 0,  // Not available from saved data
                            final_scores: (data.scores || []).map((s, idx) => ({
                                name: s.name,
                                rank: s.rank,
                                score: s.score,
                                type_name: s.raw_data?.type || s.name,
                                mean_utility: s.mean_utility ?? (s.raw_data?.utility ? parseFloat(s.raw_data.utility) : null),
                                n_negotiations: s.n_negotiations ?? (s.raw_data?.n_negotiations ? parseInt(s.raw_data.n_negotiations) : null),
                                n_agreements: s.raw_data?.n_agreements ? parseInt(s.raw_data.n_agreements) : null,
                                mean_advantage: s.mean_advantage,
                                mean_welfare: s.mean_welfare,
                                mean_nash_optimality: s.mean_nash_optimality,
                                mean_pareto_optimality: s.mean_pareto_optimality,
                                type_scores: s.type_scores
                            })),
                            negotiations: data.negotiations || []
                        }
                    };
                    // Load raw data for display
                    this.loadTournamentRawData(tournamentId);
                    // Load score analysis
                    this.loadScoreAnalysis(tournamentId);
                } catch (e) {
                    console.error('Failed to load saved tournament:', e);
                }
            },
            
            async loadTournamentRawData(tournamentId) {
                // Load raw data files from tournament directory
                if (!tournamentId) return;
                
                this.tournamentRawData.loading = true;
                
                try {
                    // Load available files info first
                    const filesRes = await fetch(`/api/tournament/saved/${tournamentId}/files`);
                    if (filesRes.ok) {
                        this.tournamentRawData.files = await filesRes.json();
                    }
                    
                    // Load config.json
                    const configRes = await fetch(`/api/tournament/saved/${tournamentId}/config`);
                    if (configRes.ok) {
                        this.tournamentRawData.config = await configRes.json();
                    }
                    
                    // Load type_scores.csv
                    const typeScoresRes = await fetch(`/api/tournament/saved/${tournamentId}/type_scores`);
                    if (typeScoresRes.ok) {
                        this.tournamentRawData.typeScores = await typeScoresRes.json();
                    }
                    
                    // Load all_scores.csv (can be large, load on demand)
                    const allScoresRes = await fetch(`/api/tournament/saved/${tournamentId}/all_scores`);
                    if (allScoresRes.ok) {
                        const data = await allScoresRes.json();
                        this.tournamentRawData.allScores = data.scores || [];
                    }
                    
                } catch (e) {
                    console.error('Failed to load tournament raw data:', e);
                } finally {
                    this.tournamentRawData.loading = false;
                }
            },
            
            resetTournamentRawData() {
                this.tournamentRawData = {
                    loading: false,
                    config: null,
                    typeScores: null,
                    allScores: null,
                    details: null,
                    files: null,
                    activeTab: 'config',
                };
            },
            
            async loadScoreAnalysis(tournamentId = null) {
                // Load score analysis for a saved tournament
                const id = tournamentId || this.selectedTournament?.id;
                if (!id || !this.selectedTournament?._fromSaved) return;
                
                this.scoreAnalysis.loading = true;
                
                try {
                    const params = new URLSearchParams({
                        metric: this.scoreAnalysis.metric,
                        statistic: this.scoreAnalysis.statistic,
                    });
                    if (this.scoreAnalysis.scenario) {
                        params.append('scenario', this.scoreAnalysis.scenario);
                    }
                    if (this.scoreAnalysis.partner) {
                        params.append('partner', this.scoreAnalysis.partner);
                    }
                    
                    const res = await fetch(`/api/tournament/saved/${id}/score_analysis?${params}`);
                    if (res.ok) {
                        this.scoreAnalysis.data = await res.json();
                    } else {
                        console.error('Failed to load score analysis:', res.status);
                        this.scoreAnalysis.data = null;
                    }
                } catch (e) {
                    console.error('Failed to load score analysis:', e);
                    this.scoreAnalysis.data = null;
                } finally {
                    this.scoreAnalysis.loading = false;
                }
            },
            
            resetScoreAnalysis() {
                this.scoreAnalysis = {
                    loading: false,
                    data: null,
                    metric: 'utility',
                    statistic: 'mean',
                    scenario: '',
                    partner: '',
                };
            },
            
            async loadSavedNegotiationTrace(tournamentId, negotiationIndex) {
                // Set loading state
                this.loadingTraceIndex = negotiationIndex;
                
                try {
                    // Use the new /full endpoint which returns all data in one call
                    const res = await fetch(`/api/tournament/saved/${tournamentId}/negotiation/${negotiationIndex}/full`);
                    if (!res.ok) throw new Error('Failed to load negotiation data');
                    const fullData = await res.json();
                    
                    // Get negotiator names from negotiators array or partners
                    const negotiatorNames = fullData.negotiators?.map(n => n.short_type || n.type || n.name) || ['Negotiator 1', 'Negotiator 2'];
                    
                    // Generate colors for negotiators
                    const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6'];
                    const negotiatorColors = negotiatorNames.map((_, idx) => colors[idx % colors.length]);
                    
                    // Build a map of negotiator ID to index from history
                    const negotiatorIdToIndex = {};
                    if (fullData.history) {
                        const uniqueNegotiators = [...new Set(fullData.history.map(r => r.negotiator).filter(n => n))];
                        uniqueNegotiators.forEach((negId, idx) => {
                            negotiatorIdToIndex[negId] = idx;
                        });
                    }
                    
                    // Convert history format to offers format expected by the UI
                    const offers = [];
                    const issueNames = fullData.issue_names || [];
                    
                    for (const row of (fullData.history || [])) {
                        if (row.offer) {
                            // Convert array offer to object with issue names as keys
                            const offerObj = {};
                            if (Array.isArray(row.offer) && issueNames.length > 0) {
                                issueNames.forEach((name, idx) => {
                                    offerObj[name] = row.offer[idx];
                                });
                            } else if (typeof row.offer === 'object' && !Array.isArray(row.offer)) {
                                Object.assign(offerObj, row.offer);
                            }
                            
                            const proposerIndex = negotiatorIdToIndex[row.negotiator] ?? 0;
                            
                            offers.push({
                                step: row.step,
                                proposer: negotiatorNames[proposerIndex] || row.negotiator,
                                proposer_index: proposerIndex,
                                offer: offerObj,
                                utilities: row.utilities || fullData.final_utilities || [0, 0],
                                time: 0,
                                relative_time: row.relative_time || 0
                            });
                        }
                    }
                    
                    // Determine final step and agreement info
                    const lastStep = offers.length > 0 ? Math.max(...offers.map(o => o.step)) : 0;
                    const hasAgreement = fullData.has_agreement || false;
                    
                    // Build agreement object from array if needed
                    let agreement = null;
                    if (hasAgreement && fullData.agreement) {
                        if (Array.isArray(fullData.agreement) && issueNames.length > 0) {
                            agreement = {};
                            issueNames.forEach((name, idx) => {
                                agreement[name] = fullData.agreement[idx];
                            });
                        } else if (typeof fullData.agreement === 'object' && !Array.isArray(fullData.agreement)) {
                            agreement = fullData.agreement;
                        } else {
                            // Last offer as agreement
                            agreement = offers.length > 0 ? offers[offers.length - 1]?.offer : null;
                        }
                    }
                    
                    // Create a complete negotiation object matching the viewer's expectations
                    const negotiation = {
                        id: `saved-${tournamentId}-${negotiationIndex}`,
                        scenario: fullData.scenario,
                        step: lastStep,
                        n_steps: fullData.n_steps || null,
                        relative_time: offers.length > 0 ? (offers[offers.length - 1]?.relative_time || 1.0) : 1.0,
                        offers: offers,
                        negotiator_names: negotiatorNames,
                        negotiator_colors: negotiatorColors,
                        agreement: agreement,
                        final_utilities: fullData.final_utilities || null,
                        end_reason: hasAgreement ? 'agreement' : 'completed',
                        mechanism_type: 'SAOMechanism',
                        // Include outcome_space_data for 2D utility visualization
                        outcome_space_data: fullData.outcome_space_data || null,
                        // Include optimality stats for agreement analysis
                        optimality_stats: hasAgreement ? {
                            pareto_optimality: fullData.pareto_optimality,
                            nash_optimality: fullData.nash_optimality,
                            kalai_optimality: fullData.kalai_optimality,
                            max_welfare_optimality: fullData.max_welfare_optimality,
                            ks_optimality: fullData.ks_optimality,
                        } : null,
                        // Mark this as a saved negotiation so controls are disabled
                        isSaved: true,
                        isFromTournament: true,
                        tournamentId: tournamentId,
                        pendingStart: false,
                        paused: false
                    };
                    
                    // Store reference to return to tournament
                    this._returnToTournament = this.selectedTournament;
                    
                    // Switch to negotiations page and set as current
                    this.currentPage = 'negotiations';
                    this.currentNegotiation = negotiation;
                    
                    // Clear loading state
                    this.loadingTraceIndex = null;
                    
                    // Initialize plots after DOM updates
                    this.$nextTick(() => {
                        this.initOutcomeSpacePlot();
                        this.initUtilityTimelinePlots();
                        this.initHistogramPlot();
                    });
                    
                    // Debug logging
                    console.log('Loaded negotiation object:', {
                        id: negotiation.id,
                        offers_count: negotiation.offers?.length,
                        agreement: negotiation.agreement,
                        end_reason: negotiation.end_reason,
                        outcome_space_data: !!negotiation.outcome_space_data,
                        final_utilities: negotiation.final_utilities
                    });
                    
                } catch (e) {
                    console.error('Failed to load saved negotiation trace:', e);
                    this.loadingTraceIndex = null;
                    alert('Failed to load negotiation trace. See console for details.');
                }
            },
            
            // Load a negotiation from a file path (CSV or folder)
            async loadNegotiationFromFile() {
                if (!this.loadNegotiationPath?.trim()) {
                    this.loadNegotiationError = 'Please enter a file path';
                    return;
                }
                
                this.loadNegotiationLoading = true;
                this.loadNegotiationError = null;
                
                try {
                    const res = await fetch('/api/tournament/load_negotiation_from_file', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ path: this.loadNegotiationPath.trim() })
                    });
                    
                    if (!res.ok) {
                        const err = await res.json().catch(() => ({ detail: 'Failed to load negotiation' }));
                        throw new Error(err.detail || 'Failed to load negotiation');
                    }
                    
                    const fullData = await res.json();
                    
                    // Get negotiator names from negotiators array or partners
                    const negotiatorNames = fullData.negotiators?.map(n => n.short_type || n.type || n.name) || ['Negotiator 1', 'Negotiator 2'];
                    
                    // Generate colors for negotiators
                    const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6'];
                    const negotiatorColors = negotiatorNames.map((_, idx) => colors[idx % colors.length]);
                    
                    // Build a map of negotiator ID to index from history
                    const negotiatorIdToIndex = {};
                    if (fullData.history) {
                        const uniqueNegotiators = [...new Set(fullData.history.map(r => r.negotiator).filter(n => n))];
                        uniqueNegotiators.forEach((negId, idx) => {
                            negotiatorIdToIndex[negId] = idx;
                        });
                    }
                    
                    // Convert history format to offers format expected by the UI
                    const offers = [];
                    const issueNames = fullData.issue_names || [];
                    
                    for (const row of (fullData.history || [])) {
                        if (row.offer) {
                            // Convert array offer to object with issue names as keys
                            const offerObj = {};
                            if (Array.isArray(row.offer) && issueNames.length > 0) {
                                issueNames.forEach((name, idx) => {
                                    offerObj[name] = row.offer[idx];
                                });
                            } else if (typeof row.offer === 'object' && !Array.isArray(row.offer)) {
                                Object.assign(offerObj, row.offer);
                            }
                            
                            const proposerIndex = negotiatorIdToIndex[row.negotiator] ?? 0;
                            
                            offers.push({
                                step: row.step,
                                proposer: negotiatorNames[proposerIndex] || row.negotiator,
                                proposer_index: proposerIndex,
                                offer: offerObj,
                                utilities: row.utilities || fullData.final_utilities || [0, 0],
                                time: 0,
                                relative_time: row.relative_time || 0
                            });
                        }
                    }
                    
                    // Determine final step and agreement info
                    const lastStep = offers.length > 0 ? Math.max(...offers.map(o => o.step)) : 0;
                    const hasAgreement = fullData.has_agreement || false;
                    
                    // Build agreement object from array if needed
                    let agreement = null;
                    if (hasAgreement && fullData.agreement) {
                        if (Array.isArray(fullData.agreement) && issueNames.length > 0) {
                            agreement = {};
                            issueNames.forEach((name, idx) => {
                                agreement[name] = fullData.agreement[idx];
                            });
                        } else if (typeof fullData.agreement === 'object' && !Array.isArray(fullData.agreement)) {
                            agreement = fullData.agreement;
                        } else {
                            // Last offer as agreement
                            agreement = offers.length > 0 ? offers[offers.length - 1]?.offer : null;
                        }
                    }
                    
                    // Extract scenario name from path
                    const scenarioName = fullData.scenario || this.loadNegotiationPath.split('/').pop().replace(/\.csv$/, '');
                    
                    // Create a complete negotiation object matching the viewer's expectations
                    const negotiation = {
                        id: `file-${Date.now()}`,
                        scenario: scenarioName,
                        step: lastStep,
                        n_steps: fullData.n_steps || null,
                        relative_time: offers.length > 0 ? (offers[offers.length - 1]?.relative_time || 1.0) : 1.0,
                        offers: offers,
                        negotiator_names: negotiatorNames,
                        negotiator_colors: negotiatorColors,
                        agreement: agreement,
                        final_utilities: fullData.final_utilities || null,
                        end_reason: hasAgreement ? 'agreement' : 'completed',
                        mechanism_type: 'SAOMechanism',
                        // Include outcome_space_data for 2D utility visualization
                        outcome_space_data: fullData.outcome_space_data || null,
                        // Include optimality stats for agreement analysis
                        optimality_stats: hasAgreement ? {
                            pareto_optimality: fullData.pareto_optimality,
                            nash_optimality: fullData.nash_optimality,
                            kalai_optimality: fullData.kalai_optimality,
                            max_welfare_optimality: fullData.max_welfare_optimality,
                            ks_optimality: fullData.ks_optimality,
                        } : null,
                        // Mark this as a saved negotiation so controls are disabled
                        isSaved: true,
                        isFromFile: true,
                        sourcePath: this.loadNegotiationPath,
                        pendingStart: false,
                        paused: false
                    };
                    
                    // Close modal and switch to negotiations page
                    this.showLoadNegotiation = false;
                    this.loadNegotiationPath = '';
                    this.currentPage = 'negotiations';
                    this.currentNegotiation = negotiation;
                    
                    // Initialize plots after DOM updates
                    this.$nextTick(() => {
                        this.initOutcomeSpacePlot();
                        this.initUtilityTimelinePlots();
                        this.initHistogramPlot();
                    });
                    
                    // Show notification
                    this.showToast(`Loaded negotiation from file: ${scenarioName}`, 'success');
                    
                } catch (e) {
                    console.error('Failed to load negotiation from file:', e);
                    this.loadNegotiationError = e.message || 'Failed to load negotiation';
                } finally {
                    this.loadNegotiationLoading = false;
                }
            },
            
            // Initialize tournament tables
            initTournamentsTables() {
                this.$nextTick(() => {
                    this.initRunningTournamentsTable();
                    this.initCompletedTournamentsTable();
                    this.initSavedTournamentsTable();
                    
                    // Auto-load saved tournaments on startup
                    this.loadSavedTournaments();
                });
            },
            
            initRunningTournamentsTable() {
                const container = document.getElementById('running-tournaments-table');
                if (!container || this._runningTournamentsTable) return;
                
                const self = this;
                this._runningTournamentsTable = new Tabulator(container, {
                    data: this.runningTournaments,
                    layout: "fitDataStretch",
                    height: "150px",
                    placeholder: "No running tournaments",
                    selectableRows: 1,
                    columns: [
                        { title: "ID", field: "id", width: 90, formatter: (cell) => `<code style="font-size: 11px;">#${cell.getValue()}</code>` },
                        { title: "Competitors", field: "config", minWidth: 150, formatter: (cell) => {
                            const config = cell.getValue();
                            const count = config?.competitor_types?.length || 0;
                            return `<span class="badge badge-sm badge-secondary">${count} competitors</span>`;
                        }, headerSort: false },
                        { title: "Scenarios", field: "config", width: 100, hozAlign: "center", formatter: (cell) => {
                            const config = cell.getValue();
                            return config?.scenario_paths?.length || 0;
                        }, headerSort: false },
                        { title: "Progress", field: "progress", minWidth: 180, formatter: (cell) => {
                            const progress = cell.getValue() || {};
                            const percent = Math.min(100, progress.percent || 0);
                            return `<div style="display: flex; align-items: center; gap: 8px;">
                                <div class="progress" style="width: 80px; height: 6px;">
                                    <div class="progress-bar" style="width: ${percent}%"></div>
                                </div>
                                <span style="font-size: 11px;">${progress.completed || 0}/${progress.total || 0}</span>
                            </div>`;
                        }, headerSort: false },
                        { title: "Status", field: "status", width: 80, hozAlign: "center", formatter: () => {
                            return '<span class="badge badge-primary badge-sm">Running</span>';
                        } }
                    ]
                });
                this._runningTournamentsTable.on("rowClick", function(e, row) {
                    self.selectTournament(row.getData());
                });
            },
            
            initCompletedTournamentsTable() {
                const container = document.getElementById('completed-tournaments-table');
                if (!container || this._completedTournamentsTable) return;
                
                const self = this;
                this._completedTournamentsTable = new Tabulator(container, {
                    data: this.completedTournaments,
                    layout: "fitDataStretch",
                    height: "200px",
                    placeholder: "No completed tournaments",
                    selectableRows: 1,
                    columns: [
                        { title: "ID", field: "id", width: 90, formatter: (cell) => `<code style="font-size: 11px;">#${cell.getValue()}</code>` },
                        { title: "Competitors", field: "config", minWidth: 150, formatter: (cell) => {
                            const config = cell.getValue();
                            const count = config?.competitor_types?.length || 0;
                            return `<span class="badge badge-sm badge-secondary">${count} competitors</span>`;
                        }, headerSort: false },
                        { title: "Negotiations", field: "results", width: 110, hozAlign: "center", sorter: "number", formatter: (cell) => {
                            const results = cell.getValue();
                            return results?.total_negotiations || 0;
                        } },
                        { title: "Agreements", field: "results", width: 100, hozAlign: "center", formatter: (cell) => {
                            const results = cell.getValue();
                            const rate = Math.round((results?.overall_agreement_rate || 0) * 100);
                            return `${results?.total_agreements || 0} (${rate}%)`;
                        }, headerSort: false },
                        { title: "Duration", field: "results", width: 90, hozAlign: "center", sorter: "number", formatter: (cell) => {
                            const results = cell.getValue();
                            return results?.execution_time ? `${results.execution_time.toFixed(1)}s` : '-';
                        } },
                        { title: "Status", field: "status", width: 90, hozAlign: "center", formatter: (cell) => {
                            const status = cell.getValue();
                            const badgeClass = status === 'completed' ? 'badge-success' : status === 'failed' ? 'badge-danger' : 'badge-warning';
                            return `<span class="badge badge-sm ${badgeClass}">${status}</span>`;
                        } }
                    ]
                });
                this._completedTournamentsTable.on("rowClick", function(e, row) {
                    self.selectTournament(row.getData());
                });
            },
            
            initSavedTournamentsTable() {
                const container = document.getElementById('saved-tournaments-table');
                if (!container || this._savedTournamentsTable) return;
                
                const self = this;
                this._savedTournamentsTable = new Tabulator(container, {
                    data: this.savedTournaments,
                    layout: "fitColumns",
                    height: "300px",
                    placeholder: "No saved tournaments",
                    selectableRows: 1,
                    columns: [
                        { title: "Name/ID", field: "id", widthGrow: 2, minWidth: 120, sorter: "string", formatter: (cell) => {
                            const row = cell.getRow().getData();
                            return row.name || `<code style="font-size: 11px;">${cell.getValue()}</code>`;
                        } },
                        { title: "Negotiations", field: "n_negotiations", width: 95, hozAlign: "center", resizable: false, sorter: "number" },
                        { title: "Agreements", field: "agreement_rate", width: 90, hozAlign: "center", resizable: false, formatter: (cell) => {
                            const row = cell.getRow().getData();
                            const rate = Math.round((cell.getValue() || 0) * 100);
                            return `${row.n_agreements || 0} (${rate}%)`;
                        }, headerSort: false },
                        { title: "Tags", field: "tags", width: 100, resizable: false, formatter: (cell) => {
                            const tags = cell.getValue() || [];
                            if (tags.length === 0) return '<span class="text-muted">-</span>';
                            return tags.slice(0, 2).map(t => `<span class="badge badge-neutral badge-sm">${t}</span>`).join(' ') +
                                (tags.length > 2 ? ` +${tags.length - 2}` : '');
                        }, headerSort: false },
                        { title: "Date", field: "created_at", width: 85, hozAlign: "center", resizable: false, sorter: "datetime", formatter: (cell) => {
                            const val = cell.getValue();
                            if (!val) return '-';
                            const date = new Date(val);
                            return date.toLocaleDateString();
                        } },
                        { title: "", field: "actions", width: 75, hozAlign: "center", headerSort: false, resizable: false, formatter: (cell) => {
                            const row = cell.getRow().getData();
                            const archiveIcon = row.archived 
                                ? `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="12" height="12"><path d="M3 10v11h18V10"/><path d="M21 3H3v7h18V3z"/><path d="M10 14h4"/></svg>`
                                : `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="12" height="12"><path d="M21 8v13H3V8"/><path d="M23 3H1v5h22V3z"/><path d="M10 12h4"/></svg>`;
                            const archiveTitle = row.archived ? 'Unarchive' : 'Archive';
                            return `<div style="display: flex; gap: 4px; justify-content: center;">
                                <button class="btn btn-ghost btn-xs tag-btn" title="Edit Tags" style="padding: 2px 4px;">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="12" height="12">
                                        <path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"/>
                                        <line x1="7" y1="7" x2="7.01" y2="7"/>
                                    </svg>
                                </button>
                                <button class="btn btn-ghost btn-xs archive-btn" title="${archiveTitle}" style="padding: 2px 4px;">
                                    ${archiveIcon}
                                </button>
                                <button class="btn btn-ghost btn-xs delete-btn" title="Delete" style="padding: 2px 4px;">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" width="12" height="12">
                                        <polyline points="3 6 5 6 21 6"></polyline>
                                        <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                                    </svg>
                                </button>
                            </div>`;
                        }, cellClick: (e, cell) => {
                            e.stopPropagation();
                            const row = cell.getRow().getData();
                            if (e.target.closest('.delete-btn')) {
                                self.deleteSavedTournament(row.id);
                            } else if (e.target.closest('.archive-btn')) {
                                self.toggleArchiveTournament(row.id, row.archived);
                            } else if (e.target.closest('.tag-btn')) {
                                self.openTournamentTagEditor(row);
                            }
                        } }
                    ],
                    rowFormatter: (row) => {
                        const data = row.getData();
                        if (data.archived) {
                            row.getElement().style.opacity = '0.6';
                        }
                    }
                });
                this._savedTournamentsTable.on("rowClick", function(e, row) {
                    if (!e.target.closest('.actions')) {
                        self.loadAndSelectSavedTournament(row.getData().id);
                    }
                });
            },
            
            // Tournament action handlers
            async toggleArchiveTournament(tournamentId, currentlyArchived) {
                try {
                    const res = await fetch(`/api/tournament/saved/${tournamentId}/archive`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ archived: !currentlyArchived })
                    });
                    if (!res.ok) throw new Error('Failed to toggle archive');
                    await this.loadSavedTournaments();
                } catch (e) {
                    console.error('Failed to toggle tournament archive:', e);
                    alert('Failed to archive/unarchive tournament');
                }
            },
            
            openTournamentTagEditor(tournament) {
                const newTags = prompt('Enter tags (comma-separated):', (tournament.tags || []).join(', '));
                if (newTags !== null) {
                    const tags = newTags.split(',').map(t => t.trim()).filter(t => t);
                    this.updateTournamentTags(tournament.id, tags);
                }
            },
            
            async updateTournamentTags(tournamentId, tags) {
                try {
                    const res = await fetch(`/api/tournament/saved/${tournamentId}/tags`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ tags })
                    });
                    if (!res.ok) throw new Error('Failed to update tags');
                    await this.loadSavedTournaments();
                } catch (e) {
                    console.error('Failed to update tournament tags:', e);
                    alert('Failed to update tags');
                }
            },
            
            async deleteSavedTournament(tournamentId) {
                if (!confirm('Delete this saved tournament?')) return;
                
                try {
                    await fetch(`/api/tournament/saved/${tournamentId}`, { method: 'DELETE' });
                    this.savedTournaments = this.savedTournaments.filter(t => t.id !== tournamentId);
                    if (this.selectedTournament?.id === tournamentId) {
                        this.selectedTournament = null;
                    }
                } catch (e) {
                    console.error('Failed to delete tournament:', e);
                }
            },
            
            async clearSavedTournaments() {
                if (!confirm('Delete ALL saved tournaments? This cannot be undone.')) return;
                
                try {
                    // Delete each tournament individually
                    for (const t of this.savedTournaments) {
                        await fetch(`/api/tournament/saved/${t.id}`, { method: 'DELETE' });
                    }
                    this.savedTournaments = [];
                    if (this.selectedTournament?._fromSaved) {
                        this.selectedTournament = null;
                    }
                } catch (e) {
                    console.error('Failed to clear tournaments:', e);
                }
            },
            
            // Settings
            async loadSettings() {
                try {
                    const res = await fetch('/api/settings');
                    const data = await res.json();
                    
                    // Map backend settings to frontend model
                    this.settings.darkMode = data.general?.dark_mode ?? false;
                    this.settings.colorBlindMode = data.general?.color_blind_mode ?? false;
                    this.settings.saveNegotiations = data.general?.save_negotiations ?? true;
                    this.settings.cacheScenarioStats = data.general?.cache_scenario_stats ?? true;
                    this.settings.defaultSteps = data.negotiation?.default_max_steps ?? 100;
                    this.settings.defaultDelay = data.negotiation?.default_step_delay_ms ?? 100;
                    this.settings.autoStartGenius = data.genius_bridge?.auto_start ?? true;
                    this.settings.scenarioPaths = (data.paths?.scenario_paths ?? []).join('\n');
                    this.settings.negotiatorPaths = (data.paths?.negotiator_paths ?? []).join('\n');
                    
                    // Performance settings
                    this.settings.maxOutcomesRun = data.performance?.max_outcomes_run ?? null;
                    this.settings.maxOutcomesStats = data.performance?.max_outcomes_stats ?? 1000000;
                    this.settings.maxOutcomesInfo = data.performance?.max_outcomes_info ?? 10000000;
                    
                    // Sync localStorage with backend
                    localStorage.setItem('darkMode', this.settings.darkMode.toString());
                    localStorage.setItem('colorBlindMode', this.settings.colorBlindMode.toString());
                    localStorage.setItem('saveNegotiations', this.settings.saveNegotiations.toString());
                    
                    // Apply dark mode based on loaded settings
                    document.documentElement.classList.toggle('dark-mode', this.settings.darkMode);
                    document.body.classList.toggle('dark-mode', this.settings.darkMode);
                    
                    // Apply color-blind mode based on loaded settings
                    document.documentElement.classList.toggle('color-blind-mode', this.settings.colorBlindMode);
                    document.body.classList.toggle('color-blind-mode', this.settings.colorBlindMode);
                } catch (e) {
                    console.error('Failed to load settings:', e);
                }
            },
            
            toggleDarkMode() {
                localStorage.setItem('darkMode', this.settings.darkMode);
                document.documentElement.classList.toggle('dark-mode', this.settings.darkMode);
                document.body.classList.toggle('dark-mode', this.settings.darkMode);
                // Also save to backend immediately for dark mode
                this.saveGeneralSettings();
                // Trigger chart redraws if any
                window.dispatchEvent(new CustomEvent('dark-mode-changed', { 
                    detail: { enabled: this.settings.darkMode } 
                }));
            },
            
            toggleColorBlindMode() {
                localStorage.setItem('colorBlindMode', this.settings.colorBlindMode);
                document.documentElement.classList.toggle('color-blind-mode', this.settings.colorBlindMode);
                document.body.classList.toggle('color-blind-mode', this.settings.colorBlindMode);
                // Save to backend immediately
                this.saveGeneralSettings();
                // Trigger chart redraws if any
                window.dispatchEvent(new CustomEvent('colorblind-mode-changed', { 
                    detail: { enabled: this.settings.colorBlindMode } 
                }));
            },
            
            async saveGeneralSettings() {
                try {
                    localStorage.setItem('saveNegotiations', this.settings.saveNegotiations.toString());
                    await fetch('/api/settings/general', {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ 
                            dark_mode: this.settings.darkMode,
                            color_blind_mode: this.settings.colorBlindMode,
                            save_negotiations: this.settings.saveNegotiations,
                            cache_scenario_stats: this.settings.cacheScenarioStats
                        })
                    });
                } catch (e) {
                    console.error('Failed to save general settings:', e);
                }
            },
            
            async saveSettings() {
                try {
                    localStorage.setItem('saveNegotiations', this.settings.saveNegotiations.toString());
                    const settings = {
                        general: {
                            dark_mode: this.settings.darkMode,
                            color_blind_mode: this.settings.colorBlindMode,
                            save_negotiations: this.settings.saveNegotiations,
                            cache_scenario_stats: this.settings.cacheScenarioStats
                        },
                        negotiation: {
                            default_max_steps: this.settings.defaultSteps,
                            default_step_delay_ms: this.settings.defaultDelay,
                            default_time_limit: null
                        },
                        genius_bridge: {
                            auto_start: this.settings.autoStartGenius,
                            java_path: null,
                            port: 25337
                        },
                        paths: {
                            scenario_paths: this.settings.scenarioPaths.split('\n').filter(p => p.trim()),
                            negotiator_paths: this.settings.negotiatorPaths.split('\n').filter(p => p.trim())
                        },
                        performance: {
                            max_outcomes_run: this.settings.maxOutcomesRun || null,
                            max_outcomes_stats: this.settings.maxOutcomesStats || null,
                            max_outcomes_info: this.settings.maxOutcomesInfo || null
                        }
                    };
                    
                    await fetch('/api/settings', {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(settings)
                    });
                    
                    // Also save source settings if modified
                    if (this.sourceSettings.disabled_sources.length > 0 || this.sourceSettings.custom_sources.length > 0) {
                        await fetch('/api/settings/negotiator_sources', {
                            method: 'PUT',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(this.sourceSettings)
                        });
                        // Refresh negotiator list after changing sources
                        await this.refreshNegotiators();
                    }
                    
                    this.showSettings = false;
                } catch (e) {
                    console.error('Failed to save settings:', e);
                }
            },
            
            // Export/Import settings
            async exportSettings() {
                this.exportingSettings = true;
                try {
                    const res = await fetch('/api/settings/export');
                    if (res.ok) {
                        const blob = await res.blob();
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        // Get filename from Content-Disposition header or use default
                        const disposition = res.headers.get('Content-Disposition');
                        const filenameMatch = disposition?.match(/filename=([^;]+)/);
                        a.download = filenameMatch ? filenameMatch[1] : 'negmas_settings.zip';
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    } else {
                        console.error('Export failed:', res.statusText);
                        alert('Failed to export settings');
                    }
                } catch (e) {
                    console.error('Failed to export settings:', e);
                    alert('Failed to export settings');
                } finally {
                    this.exportingSettings = false;
                }
            },
            
            async handleSettingsImport(event) {
                const file = event.target.files?.[0];
                if (!file) return;
                
                this.importingSettings = true;
                this.importStatus = '';
                
                try {
                    const formData = new FormData();
                    formData.append('file', file);
                    
                    const res = await fetch('/api/settings/import', {
                        method: 'POST',
                        body: formData
                    });
                    
                    const result = await res.json();
                    
                    if (result.status === 'success') {
                        this.importStatus = `Imported ${result.imported?.length || 0} files`;
                        // Reload settings
                        await this.loadSettings();
                        // Show success message briefly
                        setTimeout(() => {
                            this.importStatus = 'Settings imported! Refresh page to apply all changes.';
                        }, 1000);
                    } else if (result.status === 'partial') {
                        this.importStatus = `Imported ${result.imported?.length || 0} files with some errors`;
                        await this.loadSettings();
                    } else {
                        this.importStatus = result.message || 'Import failed';
                    }
                } catch (e) {
                    console.error('Failed to import settings:', e);
                    this.importStatus = 'Import failed';
                } finally {
                    this.importingSettings = false;
                    // Clear the file input
                    event.target.value = '';
                }
            },
            
            // Custom source management
            async handleScenarioFileSelect(event) {
                const file = event.target.files?.[0];
                if (!file) return;
                
                // For HTML file input, we get a File object but not the real path
                // We need to use a different approach - prompt user for path or use webkitRelativePath
                // For now, we'll show an alert explaining the limitation
                const fileName = file.name;
                const path = prompt(
                    `Enter the full path to the scenario file "${fileName}":\n\n` +
                    `(Due to browser security, we cannot automatically get the file path.\n` +
                    `Please enter the complete path, e.g., /Users/you/scenarios/${fileName})`
                );
                
                if (path && path.trim()) {
                    await this.addScenarioPath(path.trim());
                }
                
                // Clear the file input
                event.target.value = '';
            },
            
            async handleModuleFileSelect(event) {
                const file = event.target.files?.[0];
                if (!file) return;
                
                const fileName = file.name;
                const path = prompt(
                    `Enter the full path to the Python module "${fileName}":\n\n` +
                    `(Due to browser security, we cannot automatically get the file path.\n` +
                    `Please enter the complete path, e.g., /Users/you/negotiators/${fileName})`
                );
                
                if (path && path.trim()) {
                    await this.addModulePath(path.trim());
                }
                
                // Clear the file input
                event.target.value = '';
            },
            
            async addScenarioPath(path) {
                // Validate the scenario path
                try {
                    const res = await fetch('/api/sources/scenario/validate', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ path })
                    });
                    const result = await res.json();
                    
                    if (!result.valid) {
                        alert(`Invalid scenario path: ${result.error}`);
                        return;
                    }
                    
                    // Add to settings
                    const paths = (this.settings.scenarioPaths || '').split('\n').filter(p => p.trim());
                    if (!paths.includes(path)) {
                        paths.push(path);
                        this.settings.scenarioPaths = paths.join('\n');
                    }
                    
                    // Show success
                    alert(`Added scenario: ${result.name} (${result.format} format, ${result.n_negotiators} negotiators)`);
                } catch (e) {
                    console.error('Failed to validate scenario path:', e);
                    alert('Failed to validate scenario path');
                }
            },
            
            async addModulePath(path) {
                // Validate/inspect the module
                try {
                    const res = await fetch('/api/sources/module/inspect', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ path, dynamic: false })
                    });
                    const result = await res.json();
                    
                    if (!result.success) {
                        alert(`Failed to inspect module: ${result.error}`);
                        return;
                    }
                    
                    if (result.classes.length === 0) {
                        alert('No negotiator, mechanism, or BOA component classes found in this module.');
                        return;
                    }
                    
                    // Show what was found
                    const summary = [];
                    if (result.negotiators.length > 0) {
                        summary.push(`${result.negotiators.length} negotiator(s): ${result.negotiators.map(c => c.name).join(', ')}`);
                    }
                    if (result.mechanisms.length > 0) {
                        summary.push(`${result.mechanisms.length} mechanism(s): ${result.mechanisms.map(c => c.name).join(', ')}`);
                    }
                    if (result.boa_components.length > 0) {
                        summary.push(`${result.boa_components.length} BOA component(s): ${result.boa_components.map(c => c.name).join(', ')}`);
                    }
                    
                    // Add to settings
                    const paths = (this.settings.negotiatorPaths || '').split('\n').filter(p => p.trim());
                    if (!paths.includes(path)) {
                        paths.push(path);
                        this.settings.negotiatorPaths = paths.join('\n');
                    }
                    
                    alert(`Added module "${result.module_name}":\n\n${summary.join('\n')}`);
                } catch (e) {
                    console.error('Failed to inspect module:', e);
                    alert('Failed to inspect module');
                }
            },
            
            removeScenarioPath(idx) {
                const paths = (this.settings.scenarioPaths || '').split('\n').filter(p => p.trim());
                paths.splice(idx, 1);
                this.settings.scenarioPaths = paths.join('\n');
            },
            
            removeNegotiatorPath(idx) {
                const paths = (this.settings.negotiatorPaths || '').split('\n').filter(p => p.trim());
                paths.splice(idx, 1);
                this.settings.negotiatorPaths = paths.join('\n');
            },
            
            openFolderBrowser(type) {
                // Since browsers don't support folder selection well, use a prompt
                const path = prompt(
                    `Enter the full path to the ${type === 'scenario' ? 'scenario folder' : 'folder'}:\n\n` +
                    `Example: /Users/you/scenarios/my_scenario`
                );
                
                if (path && path.trim()) {
                    if (type === 'scenario') {
                        this.addScenarioPath(path.trim());
                    }
                }
            },
            
            // Preset management
            async loadRecentSessions() {
                try {
                    const res = await fetch('/api/settings/presets/recent');
                    if (res.ok) {
                        const data = await res.json();
                        this.recentSessions = data.presets || [];
                    }
                } catch (e) {
                    console.error('Failed to load recent sessions:', e);
                }
            },
            
            async loadSessionPresets() {
                try {
                    const res = await fetch('/api/settings/presets/sessions');
                    if (res.ok) {
                        const data = await res.json();
                        this.sessionPresets = data.presets || [];
                    }
                } catch (e) {
                    console.error('Failed to load session presets:', e);
                }
            },
            
            loadFullSession(session) {
                // Find the scenario in the loaded scenarios
                const scenario = this.scenarios.find(s => s.path === session.scenario_path);
                const mechType = session.mechanism_type || 'SAOMechanism';
                
                // First select the mechanism to initialize defaults
                // This must happen BEFORE setting newNeg so we can override with loaded values
                this.selectMechanism(mechType);
                
                // Now set up newNeg with loaded values (this will override any defaults)
                this.newNeg = {
                    source: '',
                    scenario: scenario || { path: session.scenario_path, name: session.scenario_name },
                    negotiators: session.negotiators.map((n, i) => ({
                        type_name: n.type_name,
                        name: n.name || `Agent${i + 1}`,
                        source: n.source || 'native',
                        requires_bridge: n.requires_bridge || false,
                        is_boa: n.is_boa || false,
                        boa_config: n.boa_config || null
                    })),
                    mechanism_type: mechType,
                    mechanism_params: { ...this.newNeg.mechanism_params, ...(session.mechanism_params || {}) },
                    share_ufuns: session.share_ufuns ?? false,
                    mode: session.mode || 'realtime',
                    step_delay: session.step_delay ?? 100,
                    show_plot: session.show_plot ?? true,
                    show_offers: session.show_offers ?? true,
                    auto_start: true,
                    panels: session.panels || {
                        adjustable: true,
                        utilityView: { xAxis: 0, yAxis: 1 },
                        timeline: { xAxis: 'relative_time' }
                    }
                };
                
                // Jump directly to display tab when loading a full session
                this.negotiationTab = 'display';
            },
            
            buildSessionPreset(name) {
                return {
                    name: name,
                    scenario_path: this.newNeg.scenario?.path,
                    scenario_name: this.newNeg.scenario?.name,
                    negotiators: this.newNeg.negotiators.map(n => ({
                        type_name: n.type_name,
                        name: n.name,
                        source: n.source,
                        requires_bridge: n.requires_bridge
                    })),
                    mechanism_type: this.newNeg.mechanism_type,
                    mechanism_params: this.newNeg.mechanism_params,
                    share_ufuns: this.newNeg.share_ufuns,
                    mode: this.newNeg.mode,
                    step_delay: this.newNeg.step_delay,
                    show_plot: this.newNeg.show_plot,
                    show_offers: this.newNeg.show_offers,
                    panels: this.newNeg.panels
                };
            },
            
            async saveFullSession() {
                if (!this.savePresetName.trim() || !this.newNeg.scenario) return;
                
                try {
                    const preset = this.buildSessionPreset(this.savePresetName.trim());
                    const res = await fetch('/api/settings/presets/sessions', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(preset)
                    });
                    
                    if (res.ok) {
                        this.showSaveSessionModal = false;
                        this.savePresetName = '';
                        // Refresh the list
                        await this.loadSessionPresets();
                    }
                } catch (e) {
                    console.error('Failed to save session preset:', e);
                }
            },
            
            async deleteSessionPreset(name) {
                try {
                    const res = await fetch(`/api/settings/presets/sessions/${encodeURIComponent(name)}`, {
                        method: 'DELETE'
                    });
                    if (res.ok) {
                        await this.loadSessionPresets();
                    }
                } catch (e) {
                    console.error('Failed to delete session preset:', e);
                }
            },
            
            async addToRecentSessions() {
                if (!this.newNeg.scenario) return;
                
                try {
                    const preset = this.buildSessionPreset(this.newNeg.scenario.name);
                    await fetch('/api/settings/presets/recent', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(preset)
                    });
                } catch (e) {
                    console.error('Failed to add to recent sessions:', e);
                }
            }
        };
    }
    </script>
    
    <!-- Negotiation plotting functionality -->
    <script src="/static/js/negotiation-plots.js"></script>
    
    {% block scripts %}{% endblock %}
</body>
</html>
